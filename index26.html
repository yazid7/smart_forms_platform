<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Crypto Toolbox — Fixed</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- CryptoJS -->
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/md5.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/sha256.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/sha3.js"></script>

  <style>
    body { padding:18px; background:#f8f9fa; color:#222; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .card { border-radius:12px; box-shadow:0 6px 18px rgba(15,23,42,0.06); }
    .monos { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; }
    .cipher-output { white-space: pre-wrap; word-break: break-word; }
    .small-muted { color:#6b7280; }
    footer small { color:#6b7280; }
    .rounded-lg { border-radius:0.75rem; }
  </style>
</head>
<body data-theme="light">

<div class="container-fluid">
  <div class="d-flex align-items-center mb-3">
    <h1 class="h4 me-3">Crypto Toolbox — Fixed</h1>
    <div class="ms-auto d-flex gap-2 align-items-center">
      <div class="form-check form-switch me-2">
        <input id="darkToggle" class="form-check-input" type="checkbox">
        <label class="form-check-label" for="darkToggle">Dark</label>
      </div>
      <small class="small-muted">Client-side demo • CryptoJS + WebCrypto</small>
    </div>
  </div>

  <!-- NAV -->
  <nav class="nav nav-pills mb-3">
    <a class="nav-link active" href="#gen">Generators</a>
    <a class="nav-link" href="#fileenc">File Encrypt</a>
    <a class="nav-link" href="#keys">Keys (RSA)</a>
    <a class="nav-link" href="#single">Text / Hash</a>
    <a class="nav-link" href="#steg">Steganography</a>
    <a class="nav-link" href="#algos">Algorithms</a>
    <a class="nav-link" href="#morse">Morse</a>
    <a class="nav-link" href="#leak">Leak Check</a>
  </nav>

  <!-- GENERATORS -->
  <section id="gen" class="card mb-3 p-3">
    <h5>Generators & Passwords</h5>
    <div class="row g-3">
      <div class="col-lg-6">
        <label class="form-label">Password length: <span id="pwLenLabel">16</span></label>
        <input id="pwLen" type="range" min="6" max="128" value="16" class="form-range mb-2">
        <div class="d-flex gap-2 mb-2">
          <input id="pwLetters" type="number" class="form-control form-control-sm" style="width:110px" value="10" min="0">
          <input id="pwNums" type="number" class="form-control form-control-sm" style="width:110px" value="4" min="0">
          <input id="pwSyms" type="number" class="form-control form-control-sm" style="width:110px" value="2" min="0">
        </div>

        <div class="mb-2">
          <div class="form-check form-check-inline"><input id="incLower" class="form-check-input" type="checkbox" checked><label class="form-check-label">lower</label></div>
          <div class="form-check form-check-inline"><input id="incUpper" class="form-check-input" type="checkbox" checked><label class="form-check-label">UPPER</label></div>
          <div class="form-check form-check-inline"><input id="incNum" class="form-check-input" type="checkbox" checked><label class="form-check-label">digits</label></div>
          <div class="form-check form-check-inline"><input id="incSym" class="form-check-input" type="checkbox" checked><label class="form-check-label">symbols</label></div>
        </div>

        <div class="d-flex gap-2 mb-2">
          <button id="genPw" class="btn btn-primary btn-sm">Generate</button>
          <button id="copyPw" class="btn btn-outline-secondary btn-sm">Copy</button>
          <button id="savePw" class="btn btn-success btn-sm">Save</button>
          <button id="clearPw" class="btn btn-danger btn-sm">Clear saved</button>
          <button id="togglePw" class="btn btn-outline-secondary btn-sm">Show</button>
        </div>

        <div>
          <label>Generated password</label>
          <div id="pwOut" class="p-2 border rounded-lg monos large-text" style="min-height:44px;"></div>
          <div class="mt-1">
            <div class="progress" style="height:10px"><div id="pwBar" class="progress-bar" style="width:0%"></div></div>
            <small id="pwInfo" class="small-muted"></small>
          </div>
        </div>

        <div class="mt-3">
          <h6>Saved</h6>
          <ul id="pwSaved" class="list-group"></ul>
        </div>
      </div>

      <div class="col-lg-6">
        <h6>Random identities (incomprehensible)</h6>
        <label>Count</label>
        <input id="idCount" type="number" class="form-control form-control-sm mb-2" value="5" min="1" max="100">
        <div class="d-flex gap-2 mb-2">
          <button id="genNames" class="btn btn-secondary btn-sm">Names</button>
          <button id="genEmails" class="btn btn-secondary btn-sm">Emails</button>
          <button id="genPhrases" class="btn btn-secondary btn-sm">Passphrases</button>
        </div>
        <ul id="idList" class="list-group"></ul>

        <hr>
        <h6>OTP Simulator</h6>
        <div class="d-flex gap-2">
          <input id="otpLen" type="number" class="form-control form-control-sm" value="6" min="4" max="10" style="width:90px">
          <button id="otpPhone" class="btn btn-warning btn-sm">Phone OTP</button>
          <button id="otpEmail" class="btn btn-warning btn-sm">Email OTP</button>
        </div>
        <pre id="otpOut" class="small-muted mt-2"></pre>
      </div>
    </div>
  </section>

  <!-- FILE ENCRYPTION -->
  <section id="fileenc" class="card mb-3 p-3">
    <h5>File Encryption (AES-CBC via CryptoJS) + SHA-256 fingerprint</h5>
    <div class="row g-3 align-items-end">
      <div class="col-md-4"><label>Pick file</label><input id="fileIn" type="file" class="form-control"></div>
      <div class="col-md-4">
        <label>Passphrase</label>
        <div class="input-group">
          <input id="filePass" type="password" class="form-control form-control-lg">
          <button id="toggleFilePass" class="btn btn-outline-secondary">Show</button>
        </div>
      </div>

      <div class="col-md-4 d-flex gap-2">
        <button id="encryptFileBtn" class="btn btn-primary">Encrypt & Download</button>
        <input id="fileEncUpload" type="file" accept=".enc" class="form-control form-control-sm">
        <button id="decryptFileBtn" class="btn btn-success">Decrypt uploaded</button>
      </div>

      <div class="col-12 mt-2">
        <div class="d-flex justify-content-between align-items-center">
          <div><strong>Status:</strong> <span id="fileStatus" class="monos">Idle</span></div>
          <div>Failed attempts: <span id="fileAttempts">0</span></div>
        </div>
        <div class="mt-2 d-flex gap-2 align-items-center">
          <div>SHA-256:</div><div id="fileSha" class="monos"></div>
          <button id="copyFileSha" class="btn btn-outline-secondary btn-sm">Copy</button>
          <button id="computeFileSha" class="btn btn-outline-info btn-sm">Compute SHA-256</button>
        </div>
      </div>
    </div>
  </section>

  <!-- KEYS (RSA) -->
  <section id="keys" class="card mb-3 p-3">
    <h5>Public / Private Key (RSA-OAEP) — generate / import / export / encrypt / decrypt</h5>
    <div class="row g-2">
      <div class="col-md-2"><label>Key size</label><select id="rsaSize" class="form-select form-select-sm"><option>2048</option><option>3072</option><option>4096</option></select></div>
      <div class="col-md-5 d-flex align-items-end gap-2">
        <button id="genRsa" class="btn btn-primary btn-sm">Generate</button>
        <button id="downloadPub" class="btn btn-outline-secondary btn-sm">Download Pub</button>
        <button id="downloadPriv" class="btn btn-outline-secondary btn-sm">Download Priv</button>
        <button id="clearKeys" class="btn btn-danger btn-sm">Clear</button>
      </div>

      <div class="col-md-5 d-flex align-items-end gap-2">
        <input id="importPubFile" type="file" accept=".pem" class="form-control form-control-sm">
        <input id="importPrivFile" type="file" accept=".pem" class="form-control form-control-sm">
        <button id="importPubBtn" class="btn btn-secondary btn-sm">Import Pub</button>
        <button id="importPrivBtn" class="btn btn-secondary btn-sm">Import Priv</button>
      </div>

      <div class="col-12 mt-2">
        <label>Message</label>
        <div class="input-group mb-2">
          <textarea id="rsaMessage" class="form-control form-control-lg monos" rows="3"></textarea>
          <div class="input-group-append ms-2 d-flex flex-column gap-2">
            <button id="rsaEncrypt" class="btn btn-outline-primary btn-sm">Encrypt (public)</button>
            <button id="rsaDecrypt" class="btn btn-outline-success btn-sm">Decrypt (private)</button>
            <button id="copyRsaOut" class="btn btn-outline-secondary btn-sm">Copy</button>
          </div>
        </div>

        <div class="mt-2">
          <label>Output</label>
          <div id="rsaOutput" class="p-2 border monos cipher-output" style="min-height:80px;"></div>
        </div>

        <div class="mt-2 d-flex justify-content-between">
          <div>Stored: <span id="rsaStatus">no key</span></div>
          <div>Decrypt attempts: <span id="rsaAttempts">0</span></div>
        </div>
      </div>
    </div>
  </section>

  <!-- SINGLE / TEXT / HASH -->
  <section id="single" class="card mb-3 p-3">
    <h5>Text encryption / Hash / Comparison</h5>
    <div class="row g-3">
      <div class="col-lg-6">
        <label>Input text</label>
        <div class="input-group mb-2">
          <textarea id="textIn" class="form-control form-control-lg" rows="6"></textarea>
        </div>
        <div class="d-flex gap-2 mb-2">
          <button id="copyTextIn" class="btn btn-outline-secondary btn-sm">Copy</button>
          <button id="pasteTextIn" class="btn btn-outline-secondary btn-sm">Paste</button>
          <button id="clearTextIn" class="btn btn-danger btn-sm">Clear</button>
        </div>

        <div class="mt-2 d-flex gap-2 flex-wrap">
          <button id="caesarEnc" class="btn btn-sm btn-outline-primary">Caesar Enc</button>
          <button id="caesarDec" class="btn btn-sm btn-outline-secondary">Caesar Dec</button>
          <input id="caesarShift" type="number" class="form-control form-control-sm" style="width:90px" value="3">

          <button id="vigEnc" class="btn btn-sm btn-outline-primary">Vigenère Enc</button>
          <button id="vigDec" class="btn btn-sm btn-outline-secondary">Vigenère Dec</button>
          <input id="vigKey" type="text" class="form-control form-control-sm" style="width:120px" value="KEY">

          <button id="xorEnc" class="btn btn-sm btn-outline-primary">XOR Enc (b64)</button>
          <button id="xorDec" class="btn btn-sm btn-outline-secondary">XOR Dec</button>
          <input id="xorKey" type="text" class="form-control form-control-sm" style="width:120px" value="secret">
        </div>

        <hr>
        <h6>Hashes & fingerprints</h6>
        <div class="d-flex gap-2">
          <button id="md5Btn" class="btn btn-outline-secondary btn-sm">MD5</button>
          <button id="sha256Btn" class="btn btn-outline-secondary btn-sm">SHA-256</button>
          <button id="sha3Btn" class="btn btn-outline-secondary btn-sm">SHA3-512</button>
          <button id="compareHashBtn" class="btn btn-primary btn-sm">Compare fingerprints</button>
        </div>

        <div class="mt-2">
          <label>Hashes</label>
          <div id="hashOut" class="p-2 border monos cipher-output"></div>
        </div>
      </div>

      <div class="col-lg-6">
        <label>Symmetric (AES) — passphrase + options</label>
        <div class="input-group mb-2">
          <input id="textPass" class="form-control form-control-lg" placeholder="AES passphrase">
          <button id="toggleTextPass" class="btn btn-outline-secondary">Show</button>
        </div>

        <div class="d-flex gap-2 mb-2">
          <select id="aesMode" class="form-select form-select-sm" style="width:140px">
            <option value="CBC">AES-CBC (CryptoJS)</option>
            <option value="GCM">AES-GCM (SubtleCrypto)</option>
          </select>
          <button id="aesEncBtn" class="btn btn-outline-primary btn-sm">Encrypt</button>
          <button id="aesDecBtn" class="btn btn-outline-success btn-sm">Decrypt</button>
        </div>

        <div>
          <label>Output</label>
          <div id="textOut" class="p-2 border monos cipher-output" style="min-height:200px;"></div>
        </div>

        <div class="mt-2 d-flex gap-2">
          <button id="copyTextOut" class="btn btn-sm btn-outline-secondary">Copy</button>
          <button id="saveTextOut" class="btn btn-sm btn-success">Save</button>
          <button id="clearTextSaved" class="btn btn-sm btn-danger">Clear saved</button>
        </div>

        <ul id="textSaved" class="list-group mt-2"></ul>
      </div>
    </div>
  </section>

  <!-- STEGANOGRAPHY -->
  <section id="steg" class="card mb-3 p-3">
    <h5>Image Steganography (LSB) — AES protected payload</h5>
    <div class="row g-2">
      <div class="col-md-6">
        <label>Cover image (PNG recommended)</label>
        <input id="coverFile" type="file" accept="image/*" class="form-control mb-2">
        <label>Message to hide</label>
        <textarea id="stegMsg" class="form-control mb-2" rows="4"></textarea>
        <label>Password</label>
        <div class="input-group mb-2">
          <input id="stegPass" class="form-control" placeholder="password to protect hidden data" type="password">
          <button id="toggleStegPass" class="btn btn-outline-secondary">Show</button>
        </div>

        <div class="d-flex gap-2 mb-2">
          <button id="stegHide" class="btn btn-primary btn-sm">Hide & Preview</button>
          <input id="stegUpload" type="file" accept="image/*" class="form-control form-control-sm">
          <button id="stegReveal" class="btn btn-success btn-sm">Reveal (upload)</button>
          <button id="downloadSteg" class="btn btn-outline-secondary btn-sm" disabled>Download</button>
        </div>
        <div>Status: <span id="stegStatus">Idle</span> — Attempts: <span id="stegAttempts">0</span></div>
      </div>

      <div class="col-md-6">
        <label>Preview</label>
        <canvas id="stegCanvas" class="border" style="max-width:100%"></canvas>
      </div>
    </div>
    <small class="text-muted">Hidden data is AES-encrypted (PBKDF2 + AES-CBC) then base64 and embedded via LSB. If password wrong, reveal will fail.</small>
  </section>

  <!-- ALGORITHMS -->
  <section id="algos" class="card mb-3 p-3">
    <h5>Algorithms & Notes</h5>
    <div class="accordion" id="algAcc">
      <div class="accordion-item">
        <h2 class="accordion-header"><button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#a1">AES (symmetric)</button></h2>
        <div id="a1" class="accordion-collapse collapse show" data-bs-parent="#algAcc"><div class="accordion-body small-muted">AES-CBC via CryptoJS (not authenticated). AES-GCM via SubtleCrypto provided for text (authenticated). Use strong KDFs in production (Argon2 recommended).</div></div>
      </div>
      <div class="accordion-item">
        <h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#a2">RSA-OAEP (asymmetric)</button></h2>
        <div id="a2" class="accordion-collapse collapse" data-bs-parent="#algAcc"><div class="accordion-body small-muted">RSA-OAEP used for small payloads. Browser SubtleCrypto used here to avoid incompatible PEM library issues.</div></div>
      </div>
    </div>
  </section>

  <!-- MORSE -->
  <section id="morse" class="card mb-3 p-3">
    <h5>Morse code (extended)</h5>
    <div class="row g-2">
      <div class="col-md-6">
        <textarea id="morseIn" class="form-control mb-2" rows="3"></textarea>
        <div class="d-flex gap-2">
          <button id="morseEnc" class="btn btn-sm btn-outline-primary">Encode</button>
          <button id="morseDec" class="btn btn-sm btn-outline-secondary">Decode</button>
        </div>
      </div>
      <div class="col-md-6">
        <div id="morseOut" class="p-2 border monos cipher-output" style="min-height:120px"></div>
      </div>
    </div>
    <hr>
    <div style="max-height:220px; overflow:auto">
      <table class="table table-sm table-bordered">
        <thead><tr><th>Char</th><th>Morse</th><th>Char</th><th>Morse</th></tr></thead>
        <tbody id="morseTable"></tbody>
      </table>
    </div>
  </section>

  <!-- LEAK -->
  <section id="leak" class="card mb-4 p-3">
    <h5>Password leak helper & email check (simulated)</h5>
    <div class="row g-2">
      <div class="col-md-4">
        <label>Email</label>
        <input id="leakEmail" class="form-control" placeholder="email@example.com">
        <div class="mt-2 d-flex gap-2">
          <button id="leakCheckEmail" class="btn btn-outline-primary btn-sm">Check Email (sim)</button>
          <div id="leakEmailOut" class="monos"></div>
        </div>
      </div>
      <div class="col-md-8">
        <label>Password (SHA-1 prefix for HIBP)</label>
        <div class="input-group mb-2">
          <input id="leakPass" class="form-control form-control-lg" placeholder="password">
          <button id="toggleLeakPass" class="btn btn-outline-secondary">Show</button>
        </div>
        <div class="d-flex gap-2">
          <button id="leakCompute" class="btn btn-outline-primary btn-sm">Compute SHA-1 prefix</button>
          <div id="leakOut" class="monos"></div>
        </div>
        <small class="text-muted">This shows SHA-1 prefix for k-anonymity to use with HaveIBeenPwned. This tool does not call external APIs.</small>
      </div>
    </div>
  </section>

  <footer class="mb-5 text-center">
    <small>Educational. For production use authenticated encryption + server-side protections.</small>
  </footer>
</div>

<!-- Bootstrap JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

<script>
/* ---------------------------
   Utilities
   --------------------------- */
function rngInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function copyTextToClipboard(text){ navigator.clipboard?.writeText(text).catch(()=>{}); }
function bytesToBase64(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); }
function base64ToBytes(b64){ const bin = atob(b64); const arr = new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i); return arr; }
function arrayBufferToBase64(ab){ return bytesToBase64(ab); }
function base64ToArrayBuffer(b64){ return base64ToBytes(b64).buffer; }
function arrayBufferToPem(buffer, type){ // type: PUBLIC KEY or PRIVATE KEY
  const b64 = bytesToBase64(buffer);
  const chunk = b64.match(/.{1,64}/g).join('\n');
  return `-----BEGIN ${type}-----\n${chunk}\n-----END ${type}-----`;
}
function pemToArrayBuffer(pem){
  const b64 = pem.replace(/-----.*?-----/gs,'').replace(/\s+/g,'');
  return base64ToArrayBuffer(b64);
}
function hexFromBuffer(buf){
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('');
}
function hexFromBufferUpper(buf){ return hexFromBuffer(buf).toUpperCase(); }
function bufToUtf8(buf){ return new TextDecoder().decode(buf); }

/* ---------------------------
   Dark Mode toggle
   --------------------------- */
document.getElementById('darkToggle').addEventListener('change', (e)=>{
  if(e.target.checked) document.body.style.background='#081124', document.body.style.color='#e6eef8';
  else { document.body.style.background='#f8f9fa'; document.body.style.color='#222'; }
});

/* ---------------------------
   Password generator (grouped by '-')
   --------------------------- */
const pwLen = document.getElementById('pwLen'), pwLenLabel = document.getElementById('pwLenLabel');
const pwOut = document.getElementById('pwOut'), pwBar = document.getElementById('pwBar'), pwInfo = document.getElementById('pwInfo');
pwLen.addEventListener('input', ()=> pwLenLabel.textContent = pwLen.value);

function randCharFrom(pool){ return pool.charAt(rngInt(0,pool.length-1)); }
function generatePasswordFormatted(){
  const L = +pwLen.value;
  let letters = +document.getElementById('pwLetters').value || 0;
  let nums = +document.getElementById('pwNums').value || 0;
  let syms = +document.getElementById('pwSyms').value || 0;
  const lower = document.getElementById('incLower').checked;
  const upper = document.getElementById('incUpper').checked;
  const digits = document.getElementById('incNum').checked;
  const symbols = document.getElementById('incSym').checked;
  let poolLetters = '';
  if(lower) poolLetters += 'abcdefghijklmnopqrstuvwxyz';
  if(upper) poolLetters += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const poolNums = '0123456789';
  const poolSyms = '!@#$%^&*()-_=+[]{};:,.<>?/|`~';
  let sum = letters + nums + syms;
  if(sum > L){
    const factor = L / sum;
    letters = Math.max(0, Math.floor(letters*factor));
    nums = Math.max(0, Math.floor(nums*factor));
    syms = Math.max(0, Math.floor(syms*factor));
  }
  letters += L - (letters+nums+syms);
  let arr = [];
  for(let i=0;i<letters;i++) arr.push(poolLetters.charAt(rngInt(0,poolLetters.length-1)) || poolNums.charAt(rngInt(0,9)));
  for(let i=0;i<nums;i++) arr.push(poolNums.charAt(rngInt(0,poolNums.length-1)));
  for(let i=0;i<syms;i++) arr.push(poolSyms.charAt(rngInt(0,poolSyms.length-1)));
  for(let i=arr.length-1;i>0;i--){ const j=rngInt(0,i); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  let p = arr.join('');
  // format groups: use 4-chars groups
  const group = 4;
  const parts = [];
  for(let i=0;i<p.length;i+=group) parts.push(p.slice(i,i+group));
  return parts.join('-');
}
function entropyBits(pw){
  let charset=0;
  if(/[a-z]/.test(pw)) charset+=26;
  if(/[A-Z]/.test(pw)) charset+=26;
  if(/[0-9]/.test(pw)) charset+=10;
  if(/[^A-Za-z0-9]/.test(pw)) charset+=32;
  if(charset===0) charset=1;
  return Math.log2(Math.pow(charset,pw.length)) || 0;
}
function updatePwUI(pw){
  const bits = Math.round(entropyBits(pw));
  pwBar.style.width = Math.min(100,bits) + '%';
  pwBar.textContent = bits + ' bits';
  const guesses = Math.pow(2, bits);
  const seconds = guesses / 1e9;
  let human;
  if(!isFinite(seconds) || seconds>1e12) human = '>> centuries';
  else if(seconds < 60) human = seconds.toFixed(0)+'s';
  else if(seconds < 3600) human = Math.round(seconds/60)+'m';
  else if(seconds < 86400) human = Math.round(seconds/3600)+'h';
  else if(seconds < 31536000) human = Math.round(seconds/86400)+'d';
  else human = Math.round(seconds/31536000)+'y';
  pwInfo.textContent = `Est. brute-force @1e9 g/s: ${human} (${bits} bits)`;
}

document.getElementById('genPw').addEventListener('click', ()=>{
  const p = generatePasswordFormatted();
  pwOut.textContent = p;
  updatePwUI(p);
});
document.getElementById('copyPw').addEventListener('click', ()=> copyTextToClipboard(pwOut.textContent));
document.getElementById('savePw').addEventListener('click', ()=>{
  const v = pwOut.textContent; if(!v) return;
  const li = document.createElement('li'); li.className = 'list-group-item d-flex justify-content-between align-items-center monos';
  li.innerHTML = `<span>${v}</span><div><button class="btn btn-sm btn-outline-secondary copy">Copy</button> <button class="btn btn-sm btn-danger del">Del</button></div>`;
  li.querySelector('.copy').addEventListener('click', ()=> copyTextToClipboard(v));
  li.querySelector('.del').addEventListener('click', ()=> li.remove());
  document.getElementById('pwSaved').prepend(li);
});
document.getElementById('clearPw').addEventListener('click', ()=> document.getElementById('pwSaved').innerHTML = '');
document.getElementById('togglePw').addEventListener('click', (e)=>{
  if(pwOut.style.filter === 'blur(6px)'){ pwOut.style.filter='none'; e.target.textContent='Hide'; } else { pwOut.style.filter='blur(6px)'; e.target.textContent='Show'; }
});

/* Identity generator */
function randString(len){
  const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let out=''; const a = new Uint8Array(len); crypto.getRandomValues(a);
  for(let i=0;i<len;i++) out += alphabet[a[i] % alphabet.length];
  return out;
}
document.getElementById('genNames').addEventListener('click', ()=>{
  const c = Math.min(100, Math.max(1, +document.getElementById('idCount').value));
  const ul = document.getElementById('idList'); ul.innerHTML='';
  for(let i=0;i<c;i++){
    const s = randString(rngInt(6,12));
    const li = document.createElement('li'); li.className='list-group-item d-flex justify-content-between align-items-center';
    li.innerHTML = `<span>${s}</span><div><button class="btn btn-sm btn-outline-secondary copy">Copy</button></div>`;
    li.querySelector('.copy').addEventListener('click', ()=> copyTextToClipboard(s));
    ul.appendChild(li);
  }
});
document.getElementById('genEmails').addEventListener('click', ()=>{
  const c = Math.min(100, Math.max(1, +document.getElementById('idCount').value));
  const domains = ['example.com','mail.example','random.xyz','service.test'];
  const ul = document.getElementById('idList'); ul.innerHTML='';
  for(let i=0;i<c;i++){
    const user = randString(rngInt(6,10)).toLowerCase();
    const e = user + '@' + domains[rngInt(0,domains.length-1)];
    const li = document.createElement('li'); li.className='list-group-item d-flex justify-content-between align-items-center';
    li.innerHTML = `<span>${e}</span><div><button class="btn btn-sm btn-outline-secondary copy">Copy</button></div>`;
    li.querySelector('.copy').addEventListener('click', ()=> copyTextToClipboard(e));
    ul.appendChild(li);
  }
});
document.getElementById('genPhrases').addEventListener('click', ()=>{
  const c = Math.min(100, Math.max(1, +document.getElementById('idCount').value));
  const ul = document.getElementById('idList'); ul.innerHTML='';
  for(let i=0;i<c;i++){
    const p = [randString(6), randString(6), randString(6)].join('-');
    const li = document.createElement('li'); li.className='list-group-item d-flex justify-content-between align-items-center monos';
    li.innerHTML = `<span>${p}</span><div><button class="btn btn-sm btn-outline-secondary copy">Copy</button></div>`;
    li.querySelector('.copy').addEventListener('click', ()=> copyTextToClipboard(p));
    ul.appendChild(li);
  }
});

/* OTP simulator */
document.getElementById('otpPhone').addEventListener('click', ()=>{
  const l = Math.max(4, +document.getElementById('otpLen').value);
  const code = Array.from({length:l}).map(()=>rngInt(0,9)).join('');
  document.getElementById('otpOut').textContent = `Phone OTP (sim): ${code}`;
});
document.getElementById('otpEmail').addEventListener('click', ()=>{
  const l = Math.max(4, +document.getElementById('otpLen').value);
  const code = Array.from({length:l}).map(()=>rngInt(0,9)).join('');
  document.getElementById('otpOut').textContent = `Email OTP (sim): ${code}`;
});

/* ---------------------------
   File Encryption + SHA256
   --------------------------- */
let fileFailCount = 0;
function wordArrayToUint8Array(wordArray){
  const len = wordArray.sigBytes;
  const words = wordArray.words;
  const u8 = new Uint8Array(len);
  for(let i=0;i<len;i++){
    u8[i] = (words[i>>>2] >>> (24 - (i%4)*8)) & 0xFF;
  }
  return u8;
}
function uint8ArrayToWordArray(u8){
  const words = [];
  for(let i=0;i<u8.length;i+=4){
    words.push((u8[i]<<24) | (u8[i+1]<<16) | (u8[i+2]<<8) | (u8[i+3]));
  }
  return CryptoJS.lib.WordArray.create(u8);
}

document.getElementById('encryptFileBtn').addEventListener('click', async ()=>{
  const f = document.getElementById('fileIn').files[0];
  const pass = document.getElementById('filePass').value;
  if(!f || !pass){ document.getElementById('fileStatus').textContent='Select file and enter passphrase'; return; }
  document.getElementById('fileStatus').textContent = 'Encrypting...';
  const ab = await f.arrayBuffer();
  const wa = CryptoJS.lib.WordArray.create(new Uint8Array(ab));
  const salt = CryptoJS.lib.WordArray.random(128/8);
  const iv = CryptoJS.lib.WordArray.random(128/8);
  const key = CryptoJS.PBKDF2(pass, salt, { keySize: 256/32, iterations: 200000 });
  const encrypted = CryptoJS.AES.encrypt(wa, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }).ciphertext;
  const payload = {
    filename: f.name,
    salt: CryptoJS.enc.Base64.stringify(salt),
    iv: CryptoJS.enc.Base64.stringify(iv),
    iterations: 200000,
    algo: 'AES-CBC-CryptoJS',
    ciphertext: CryptoJS.enc.Base64.stringify(encrypted)
  };
  const blob = new Blob([JSON.stringify(payload)], {type:'application/octet-stream'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = f.name + '.enc'; a.click(); a.remove();
  URL.revokeObjectURL(url);
  document.getElementById('fileStatus').textContent = 'Encrypted and downloaded.';
});

document.getElementById('decryptFileBtn').addEventListener('click', async ()=>{
  const f = document.getElementById('fileEncUpload').files[0];
  const pass = document.getElementById('filePass').value;
  if(!f || !pass){ document.getElementById('fileStatus').textContent='Upload .enc and enter passphrase'; return; }
  document.getElementById('fileStatus').textContent = 'Decrypting...';
  try{
    const txt = await f.text();
    const payload = JSON.parse(txt);
    const salt = CryptoJS.enc.Base64.parse(payload.salt);
    const iv = CryptoJS.enc.Base64.parse(payload.iv);
    const key = CryptoJS.PBKDF2(pass, salt, { keySize: 256/32, iterations: payload.iterations || 200000 });
    const cipherWA = CryptoJS.enc.Base64.parse(payload.ciphertext);
    const dec = CryptoJS.AES.decrypt({ ciphertext: cipherWA }, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
    const outU8 = new Uint8Array(dec.sigBytes);
    for(let i=0;i<dec.sigBytes;i++) outU8[i] = (dec.words[i>>>2] >>> (24 - (i%4)*8)) & 0xFF;
    const blob = new Blob([outU8], {type:'application/octet-stream'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = payload.filename || 'decrypted.bin'; a.click(); a.remove();
    URL.revokeObjectURL(url);
    document.getElementById('fileStatus').textContent = 'Decrypted and downloaded.';
    fileFailCount = 0; document.getElementById('fileAttempts').textContent = fileFailCount;
  } catch(e){
    fileFailCount++; document.getElementById('fileAttempts').textContent = fileFailCount;
    document.getElementById('fileStatus').textContent = 'Decryption failed (wrong pass or corrupted).';
  }
});

/* SHA-256 fingerprint for selected file */
document.getElementById('computeFileSha').addEventListener('click', async ()=>{
  const f = document.getElementById('fileIn').files[0];
  if(!f){ alert('Select a file'); return; }
  const ab = await f.arrayBuffer();
  const hashBuf = await crypto.subtle.digest('SHA-256', ab);
  const hex = [...new Uint8Array(hashBuf)].map(b=>b.toString(16).padStart(2,'0')).join('');
  document.getElementById('fileSha').textContent = hex;
});
document.getElementById('copyFileSha').addEventListener('click', ()=> copyTextToClipboard(document.getElementById('fileSha').textContent));

/* show/hide file pass */
document.getElementById('toggleFilePass').addEventListener('click', ()=>{
  const el = document.getElementById('filePass'); el.type = (el.type==='password') ? 'text' : 'password';
  document.getElementById('toggleFilePass').textContent = el.type==='text' ? 'Hide' : 'Show';
});

/* ---------------------------
   RSA via SubtleCrypto (RSA-OAEP with SHA-256)
   - generateKey / export PEM / import PEM / encrypt / decrypt
   --------------------------- */
let rsaKeys = { publicKey: null, privateKey: null };
let rsaFailCount = 0;

async function generateRSAKeyPair(){
  const size = +document.getElementById('rsaSize').value;
  // SubtleCrypto generateKey
  const kp = await crypto.subtle.generateKey({
    name: 'RSA-OAEP',
    modulusLength: size,
    publicExponent: new Uint8Array([1,0,1]),
    hash: 'SHA-256'
  }, true, ['encrypt','decrypt']);
  rsaKeys.publicKey = kp.publicKey;
  rsaKeys.privateKey = kp.privateKey;
  document.getElementById('rsaStatus').textContent = `RSA ${size} (in-memory)`;
  document.getElementById('rsaAttempts').textContent = rsaFailCount;
}

/* Export public/private -> PEM strings */
async function exportPublicKeyPem(){
  if(!rsaKeys.publicKey) throw 'no public key';
  const spki = await crypto.subtle.exportKey('spki', rsaKeys.publicKey);
  return arrayBufferToPem(spki, 'PUBLIC KEY');
}
async function exportPrivateKeyPem(){
  if(!rsaKeys.privateKey) throw 'no private key';
  const pkcs8 = await crypto.subtle.exportKey('pkcs8', rsaKeys.privateKey);
  return arrayBufferToPem(pkcs8, 'PRIVATE KEY');
}

/* PEM <-> CryptoKey import */
async function importPublicKeyFromPem(pem){
  const ab = pemToArrayBuffer(pem);
  const key = await crypto.subtle.importKey('spki', ab, { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['encrypt']);
  rsaKeys.publicKey = key;
  document.getElementById('rsaStatus').textContent = 'Public key imported';
}
async function importPrivateKeyFromPem(pem){
  const ab = pemToArrayBuffer(pem);
  const key = await crypto.subtle.importKey('pkcs8', ab, { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['decrypt']);
  rsaKeys.privateKey = key;
  document.getElementById('rsaStatus').textContent = 'Private key imported';
}

/* Helpers to download PEM text */
function downloadText(filename, text){
  const blob = new Blob([text], {type:'application/x-pem-file'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename; a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* Convert ArrayBuffer to Base64 */
function abToBase64(ab){ return bytesToBase64(ab); }
function base64ToAb(b64){ return base64ToArrayBuffer(b64); }

/* Wire up RSA UI */
document.getElementById('genRsa').addEventListener('click', async ()=>{
  try{ document.getElementById('rsaStatus').textContent='Generating...'; await generateRSAKeyPair(); } catch(e){ document.getElementById('rsaStatus').textContent='Generate failed: ' + e; }
});
document.getElementById('downloadPub').addEventListener('click', async ()=>{
  if(!rsaKeys.publicKey){ alert('Generate or import a public key first'); return; }
  const pem = await exportPublicKeyPem();
  document.getElementById('rsaStatus').textContent = 'Public PEM ready';
  downloadText('public.pem', pem);
});
document.getElementById('downloadPriv').addEventListener('click', async ()=>{
  if(!rsaKeys.privateKey){ alert('Generate or import a private key first'); return; }
  const pem = await exportPrivateKeyPem();
  document.getElementById('rsaStatus').textContent = 'Private PEM ready';
  downloadText('private.pem', pem);
});
document.getElementById('clearKeys').addEventListener('click', ()=> { rsaKeys = { publicKey:null, privateKey:null }; rsaFailCount=0; document.getElementById('rsaStatus').textContent='no key'; document.getElementById('rsaOutput').textContent=''; document.getElementById('rsaAttempts').textContent=0; });

/* Import files for keys */
document.getElementById('importPubBtn').addEventListener('click', async ()=>{
  const f = document.getElementById('importPubFile').files[0];
  if(!f) return alert('Select a public PEM file');
  const pem = await f.text();
  try{ await importPublicKeyFromPem(pem); } catch(e){ alert('Import failed: ' + e); }
});
document.getElementById('importPrivBtn').addEventListener('click', async ()=>{
  const f = document.getElementById('importPrivFile').files[0];
  if(!f) return alert('Select a private PEM file');
  const pem = await f.text();
  try{ await importPrivateKeyFromPem(pem); } catch(e){ alert('Import failed: ' + e); }
});

document.getElementById('rsaEncrypt').addEventListener('click', async ()=>{
  const msg = document.getElementById('rsaMessage').value || '';
  if(!rsaKeys.publicKey) return alert('No public key available');
  try{
    const encBuf = await crypto.subtle.encrypt({ name:'RSA-OAEP' }, rsaKeys.publicKey, new TextEncoder().encode(msg));
    const b64 = abToBase64(encBuf);
    document.getElementById('rsaOutput').textContent = b64;
  } catch(e){
    alert('RSA encrypt failed: ' + (e.message || e));
  }
});

document.getElementById('rsaDecrypt').addEventListener('click', async ()=>{
  const b64 = document.getElementById('rsaOutput').textContent.trim();
  if(!b64) return alert('No ciphertext present');
  if(!rsaKeys.privateKey) return alert('No private key available');
  try{
    const buf = base64ToAb(b64);
    const pt = await crypto.subtle.decrypt({ name:'RSA-OAEP' }, rsaKeys.privateKey, buf);
    document.getElementById('rsaOutput').textContent = new TextDecoder().decode(pt);
    rsaFailCount = 0; document.getElementById('rsaAttempts').textContent = rsaFailCount;
  } catch(e){
    rsaFailCount++; document.getElementById('rsaAttempts').textContent = rsaFailCount;
    document.getElementById('rsaOutput').textContent = 'Decryption failed (wrong key or data)';
  }
});

document.getElementById('copyRsaOut').addEventListener('click', ()=> copyTextToClipboard(document.getElementById('rsaOutput').textContent));

/* ---------------------------
   Text ciphers & AES text (CryptoJS) fixed
   --------------------------- */
function caesarEnc(s, shift){
  return s.replace(/[A-Za-z]/g, c=>{
    const base = (c <= 'Z') ? 65 : 97;
    return String.fromCharCode((c.charCodeAt(0)-base + shift + 26) % 26 + base);
  });
}
function caesarDec(s, shift){ return caesarEnc(s, (26-shift)%26); }
document.getElementById('caesarEnc').addEventListener('click', ()=> document.getElementById('textOut').textContent = caesarEnc(document.getElementById('textIn').value || '', +document.getElementById('caesarShift').value || 3));
document.getElementById('caesarDec').addEventListener('click', ()=> document.getElementById('textOut').textContent = caesarDec(document.getElementById('textIn').value || '', +document.getElementById('caesarShift').value || 3));

function vigenere(text, key, decrypt=false){
  let ki=0, out=[];
  for(const ch of text){
    if(/[A-Za-z]/.test(ch)){
      const base = ch <= 'Z' ? 65 : 97;
      const kch = key[ki % key.length].toUpperCase(); const k = kch.charCodeAt(0)-65;
      const shift = decrypt ? (26-k) : k;
      out.push(String.fromCharCode((ch.charCodeAt(0)-base + shift)%26 + base));
      ki++;
    } else out.push(ch);
  }
  return out.join('');
}
document.getElementById('vigEnc').addEventListener('click', ()=> document.getElementById('textOut').textContent = vigenere(document.getElementById('textIn').value || '', document.getElementById('vigKey').value || 'KEY', false));
document.getElementById('vigDec').addEventListener('click', ()=> document.getElementById('textOut').textContent = vigenere(document.getElementById('textIn').value || '', document.getElementById('vigKey').value || 'KEY', true));

function xorBase64(text, key){
  const t = new TextEncoder().encode(text);
  const k = new TextEncoder().encode(key);
  const out = new Uint8Array(t.length);
  for(let i=0;i<t.length;i++) out[i] = t[i] ^ k[i % k.length];
  return bytesToBase64(out);
}
function xorFromBase64(b64, key){
  const b = base64ToBytes(b64);
  const k = new TextEncoder().encode(key);
  const out = new Uint8Array(b.length);
  for(let i=0;i<b.length;i++) out[i] = b[i] ^ k[i % k.length];
  return new TextDecoder().decode(out);
}
document.getElementById('xorEnc').addEventListener('click', ()=> document.getElementById('textOut').textContent = xorBase64(document.getElementById('textIn').value || '', document.getElementById('xorKey').value || 'secret'));
document.getElementById('xorDec').addEventListener('click', ()=> {
  try{ document.getElementById('textOut').textContent = xorFromBase64(document.getElementById('textOut').textContent || '', document.getElementById('xorKey').value || 'secret'); } catch(e){ document.getElementById('textOut').textContent = 'XOR decode failed'; }
});

/* AES text encryption & decryption (CryptoJS CBC with PBKDF2) */
async function aesEncryptTextCryptoJS(plain, pass){
  const salt = CryptoJS.lib.WordArray.random(128/8);
  const iv = CryptoJS.lib.WordArray.random(128/8);
  const key = CryptoJS.PBKDF2(pass, salt, { keySize: 256/32, iterations: 200000 });
  const encrypted = CryptoJS.AES.encrypt(plain, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
  const payload = { algo:'AES-CBC-CryptoJS', salt: CryptoJS.enc.Base64.stringify(salt), iv: CryptoJS.enc.Base64.stringify(iv), iterations:200000, ciphertext: CryptoJS.enc.Base64.stringify(encrypted.ciphertext) };
  return payload;
}
async function aesDecryptTextCryptoJS(payload, pass){
  try{
    const salt = CryptoJS.enc.Base64.parse(payload.salt);
    const iv = CryptoJS.enc.Base64.parse(payload.iv);
    const key = CryptoJS.PBKDF2(pass, salt, { keySize: 256/32, iterations: payload.iterations || 200000 });
    const cipherWA = CryptoJS.enc.Base64.parse(payload.ciphertext);
    const dec = CryptoJS.AES.decrypt({ ciphertext: cipherWA }, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
    const out = dec.toString(CryptoJS.enc.Utf8);
    if(!out) throw new Error('Empty decrypt');
    return out;
  } catch(e){ throw e; }
}

/* AES GCM using Subtle (for text) */
async function subtleAesGcmEncrypt(plain, pass){
  const enc = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']);
  const key = await crypto.subtle.deriveKey({ name:'PBKDF2', salt, iterations:200000, hash:'SHA-256' }, keyMaterial, { name:'AES-GCM', length:256 }, true, ['encrypt','decrypt']);
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, enc.encode(plain));
  return { algo:'AES-GCM-Subtle', salt: bytesToBase64(salt), iv: bytesToBase64(iv), ciphertext: bytesToBase64(ct), iterations:200000 };
}
async function subtleAesGcmDecrypt(payload, pass){
  const enc = new TextEncoder(), dec = new TextDecoder();
  const salt = base64ToBytes(payload.salt);
  const iv = base64ToBytes(payload.iv);
  const keyMaterial = await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']);
  const key = await crypto.subtle.deriveKey({ name:'PBKDF2', salt, iterations: payload.iterations || 200000, hash:'SHA-256' }, keyMaterial, { name:'AES-GCM', length:256 }, true, ['encrypt','decrypt']);
  const pt = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, key, base64ToBytes(payload.ciphertext).buffer);
  return dec.decode(pt);
}

/* UI handlers for AES */
document.getElementById('aesEncBtn').addEventListener('click', async ()=>{
  const pass = document.getElementById('textPass').value || '';
  if(!pass) return alert('Enter passphrase');
  const plain = document.getElementById('textIn').value || '';
  const mode = document.getElementById('aesMode').value;
  if(mode === 'CBC'){
    try{
      const payload = await aesEncryptTextCryptoJS(plain, pass);
      document.getElementById('textOut').textContent = JSON.stringify(payload);
    } catch(e){ alert('Encryption failed: '+e); }
  } else {
    try{
      const payload = await subtleAesGcmEncrypt(plain, pass);
      document.getElementById('textOut').textContent = JSON.stringify(payload);
    } catch(e){ alert('GCM encrypt failed: ' + e); }
  }
});

document.getElementById('aesDecBtn').addEventListener('click', async ()=>{
  const pass = document.getElementById('textPass').value || '';
  if(!pass) return alert('Enter passphrase');
  try{
    const payload = JSON.parse(document.getElementById('textOut').textContent || '{}');
    if(payload.algo === 'AES-CBC-CryptoJS') {
      const out = await aesDecryptTextCryptoJS(payload, pass);
      document.getElementById('textOut').textContent = out;
    } else if(payload.algo === 'AES-GCM-Subtle'){
      const out = await subtleAesGcmDecrypt(payload, pass);
      document.getElementById('textOut').textContent = out;
    } else throw 'Unknown payload';
  } catch(e){
    document.getElementById('textOut').textContent = 'AES decryption failed';
  }
});

/* show/hide text AES pass */
document.getElementById('toggleTextPass').addEventListener('click', ()=>{
  const el = document.getElementById('textPass'); el.type = el.type==='password' ? 'text' : 'password';
  document.getElementById('toggleTextPass').textContent = el.type==='text' ? 'Hide' : 'Show';
});

/* Hash buttons */
document.getElementById('md5Btn').addEventListener('click', ()=> {
  const t = document.getElementById('textIn').value || '';
  document.getElementById('hashOut').textContent = `MD5: ${CryptoJS.MD5(t).toString(CryptoJS.enc.Hex)}`;
});
document.getElementById('sha256Btn').addEventListener('click', ()=> {
  const t = document.getElementById('textIn').value || '';
  document.getElementById('hashOut').textContent = `SHA-256: ${CryptoJS.SHA256(t).toString(CryptoJS.enc.Hex)}`;
});
document.getElementById('sha3Btn').addEventListener('click', ()=> {
  const t = document.getElementById('textIn').value || '';
  document.getElementById('hashOut').textContent = `SHA3-512: ${CryptoJS.SHA3(t,{ outputLength:512 }).toString(CryptoJS.enc.Hex)}`;
});
document.getElementById('compareHashBtn').addEventListener('click', ()=> {
  const t = document.getElementById('textIn').value || '';
  const md5 = CryptoJS.MD5(t).toString(CryptoJS.enc.Hex);
  const sha256 = CryptoJS.SHA256(t).toString(CryptoJS.enc.Hex);
  const sha3 = CryptoJS.SHA3(t, { outputLength:512 }).toString(CryptoJS.enc.Hex);
  document.getElementById('hashOut').textContent = `MD5: ${md5}\nSHA256: ${sha256}\nSHA3-512: ${sha3}`;
});

/* copy/paste/clear text frames */
document.getElementById('copyTextIn').addEventListener('click', ()=> copyTextToClipboard(document.getElementById('textIn').value || ''));
document.getElementById('pasteTextIn').addEventListener('click', async ()=> { try{ const s = await navigator.clipboard.readText(); document.getElementById('textIn').value = s; } catch(e){ alert('Paste failed'); }});
document.getElementById('clearTextIn').addEventListener('click', ()=> document.getElementById('textIn').value = '');
document.getElementById('copyTextOut').addEventListener('click', ()=> copyTextToClipboard(document.getElementById('textOut').textContent || ''));
document.getElementById('saveTextOut').addEventListener('click', ()=> {
  const v = document.getElementById('textOut').textContent || ''; if(!v) return;
  const ul = document.getElementById('textSaved'); const li = document.createElement('li');
  li.className = 'list-group-item monos d-flex justify-content-between align-items-center';
  li.innerHTML = `<span>${v}</span><div><button class="btn btn-sm btn-outline-secondary copy">Copy</button><button class="btn btn-sm btn-danger del">Del</button></div>`;
  li.querySelector('.copy').addEventListener('click', ()=> copyTextToClipboard(v));
  li.querySelector('.del').addEventListener('click', ()=> li.remove());
  ul.prepend(li);
});
document.getElementById('clearTextSaved').addEventListener('click', ()=> document.getElementById('textSaved').innerHTML='');

/* ---------------------------
   Steganography (LSB) with AES payload
   --------------------------- */
const stegCanvas = document.getElementById('stegCanvas');
const stegCtx = stegCanvas.getContext('2d');
let coverImg = null;
let stegFail = 0;

document.getElementById('coverFile').addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const img = new Image();
  img.onload = ()=> { stegCanvas.width = img.width; stegCanvas.height = img.height; stegCtx.drawImage(img,0,0); coverImg = img; document.getElementById('stegStatus').textContent='Cover loaded'; };
  img.src = URL.createObjectURL(f);
});

/* Convert string->bits / bits->string */
function stringToBits(str){
  const bytes = new TextEncoder().encode(str);
  const bits = [];
  for(const b of bytes) for(let i=7;i>=0;i--) bits.push((b>>i)&1);
  return bits;
}
function bitsToString(bits){
  const bytes = [];
  for(let i=0;i<bits.length;i+=8){
    let val = 0;
    for(let j=0;j<8 && (i+j)<bits.length;j++) val = (val<<1) | bits[i+j];
    bytes.push(val);
  }
  return new TextDecoder().decode(new Uint8Array(bytes));
}

/* Hide: AES-encrypt payload, base64 it, write LSB */
document.getElementById('stegHide').addEventListener('click', ()=>{
  if(!coverImg){ document.getElementById('stegStatus').textContent='Upload cover image first'; return; }
  const msg = document.getElementById('stegMsg').value || '';
  const pass = document.getElementById('stegPass').value || '';
  if(!pass){ document.getElementById('stegStatus').textContent='Enter password'; return; }
  // encrypt using CryptoJS PBKDF2 + AES-CBC
  const salt = CryptoJS.lib.WordArray.random(128/8);
  const iv = CryptoJS.lib.WordArray.random(128/8);
  const key = CryptoJS.PBKDF2(pass, salt, { keySize: 256/32, iterations: 200000 });
  const ctWA = CryptoJS.AES.encrypt(msg, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }).ciphertext;
  const payload = JSON.stringify({ salt: CryptoJS.enc.Base64.stringify(salt), iv: CryptoJS.enc.Base64.stringify(iv), iterations: 200000, ciphertext: CryptoJS.enc.Base64.stringify(ctWA) });
  const b64payload = btoa(payload);
  const bits = stringToBits(b64payload);
  stegCtx.drawImage(coverImg,0,0);
  const imgd = stegCtx.getImageData(0,0,stegCanvas.width,stegCanvas.height);
  const px = imgd.data;
  const capacity = Math.floor(px.length/4) * 3;
  if(bits.length + 32 > capacity){ document.getElementById('stegStatus').textContent='Message too large for this image'; return; }
  const len = bits.length;
  const lenBits = []; for(let i=31;i>=0;i--) lenBits.push((len>>i)&1);
  const all = lenBits.concat(bits);
  let bi = 0;
  for(let i=0;i<px.length && bi<all.length;i+=4){
    for(let c=0;c<3 && bi<all.length;c++){
      px[i+c] = (px[i+c] & 0xFE) | all[bi++];
    }
  }
  stegCtx.putImageData(imgd,0,0);
  document.getElementById('stegStatus').textContent = 'Hidden — preview updated';
  // show preview: set canvas visible already; enable download
  document.getElementById('downloadSteg').disabled = false;
  document.getElementById('downloadSteg').onclick = ()=>{
    stegCanvas.toBlob(b=>{
      const url = URL.createObjectURL(b);
      const a = document.createElement('a'); a.href=url; a.download='stego.png'; a.click(); a.remove(); URL.revokeObjectURL(url);
    });
  };
});

/* Reveal - upload stego image */
document.getElementById('stegReveal').addEventListener('click', async ()=>{
  const f = document.getElementById('stegUpload').files[0];
  if(!f){ document.getElementById('stegStatus').textContent='Upload encoded image to reveal'; return; }
  const img = new Image();
  img.onload = ()=>{
    const c = document.createElement('canvas'); c.width = img.width; c.height = img.height;
    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0);
    const imgd = ctx.getImageData(0,0,c.width,c.height);
    const px = imgd.data;
    const bits = [];
    for(let i=0;i<px.length;i+=4){ bits.push(px[i]&1); bits.push(px[i+1]&1); bits.push(px[i+2]&1); }
    const lenBits = bits.slice(0,32);
    let len = 0; for(let i=0;i<32;i++) len = (len<<1) | lenBits[i];
    const payloadBits = bits.slice(32, 32+len);
    const b64payload = bitsToString(payloadBits);
    try{
      const payload = JSON.parse(atob(b64payload));
      const pass = document.getElementById('stegPass').value || '';
      if(!pass){ document.getElementById('stegStatus').textContent='Enter password to decrypt hidden message'; return; }
      const salt = CryptoJS.enc.Base64.parse(payload.salt);
      const iv = CryptoJS.enc.Base64.parse(payload.iv);
      const key = CryptoJS.PBKDF2(pass, salt, { keySize: 256/32, iterations: payload.iterations || 200000 });
      const cipherWA = CryptoJS.enc.Base64.parse(payload.ciphertext);
      const dec = CryptoJS.AES.decrypt({ ciphertext: cipherWA }, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
      const out = dec.toString(CryptoJS.enc.Utf8);
      if(!out) throw 'Decryption empty';
      document.getElementById('stegStatus').textContent = 'Revealed';
      // place revealed text into stegMsg (or output area)
      document.getElementById('stegMsg').value = out;
      stegFail = 0; document.getElementById('stegAttempts').textContent = stegFail;
    } catch(e){
      stegFail++; document.getElementById('stegAttempts').textContent = stegFail;
      document.getElementById('stegStatus').textContent = 'Reveal failed (wrong password or corrupted)';
    }
  };
  img.src = URL.createObjectURL(f);
});

/* show/hide steg pass */
document.getElementById('toggleStegPass').addEventListener('click', ()=>{
  const el = document.getElementById('stegPass'); el.type = el.type==='password' ? 'text' : 'password';
  document.getElementById('toggleStegPass').textContent = el.type==='text' ? 'Hide' : 'Show';
});

/* ---------------------------
   Morse table
   --------------------------- */
const morseMap = {
  'A':'.-','B':'-...','C':'-.-.','D':'-..','E':'.','F':'..-.','G':'--.','H':'....','I':'..','J':'.---',
  'K':'-.-','L':'.-..','M':'--','N':'-.','O':'---','P':'.--.','Q':'--.-','R':'.-.','S':'...','T':'-',
  'U':'..-','V':'...-','W':'.--','X':'-..-','Y':'-.--','Z':'--..',
  '0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....','6':'-....','7':'--...','8':'---..','9':'----.',
  '.':'.-.-.-',',':'--..--','?':'..--..','!':'-.-.--','/':'-..-.','(':'-.--.',')':'-.--.-','&':'.-...',
  ':':'---...',';':'-.-.-.','=':'-...-','+':'.-.-.','-':'-....-','_':'..--.-','"':'.-..-.','$':'...-..-','@':'.--.-.','#':'......','*':'-..-.-'
};
const revM = {}; for(const k in morseMap) revM[morseMap[k]] = k;
function morseEncode(t){ return t.toUpperCase().split('').map(ch => ch===' ' ? '/' : (morseMap[ch]||'?')).join(' '); }
function morseDecode(s){ return s.split(' ').map(token => token==='/' ? ' ' : (revM[token]||'?')).join(''); }
document.getElementById('morseEnc').addEventListener('click', ()=> document.getElementById('morseOut').textContent = morseEncode(document.getElementById('morseIn').value || ''));
document.getElementById('morseDec').addEventListener('click', ()=> document.getElementById('morseOut').textContent = morseDecode(document.getElementById('morseIn').value || ''));
(function fillMorseTable(){
  const tbody = document.getElementById('morseTable'); const keys = Object.keys(morseMap).sort();
  for(let i=0;i<keys.length;i+=2){
    const a = keys[i], b = keys[i+1]||'';
    const row = document.createElement('tr'); row.innerHTML = `<td>${a}</td><td>${morseMap[a]||''}</td><td>${b}</td><td>${morseMap[b]||''}</td>`;
    tbody.appendChild(row);
  }
})();

/* ---------------------------
   Leak check & SHA-1 prefix
   --------------------------- */
const simulatedEmails = {'alice@example.com':true,'bob@example.com':true};
document.getElementById('leakCheckEmail').addEventListener('click', ()=>{
  const e = (document.getElementById('leakEmail').value||'').toLowerCase().trim();
  if(!e) return alert('Enter email');
  document.getElementById('leakEmailOut').textContent = simulatedEmails[e] ? 'Found in simulated breaches' : 'No record in simulated DB';
});
document.getElementById('leakCompute').addEventListener('click', async ()=>{
  const p = document.getElementById('leakPass').value || '';
  if(!p) return alert('Enter password');
  const buf = await crypto.subtle.digest('SHA-1', new TextEncoder().encode(p));
  const hex = [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('').toUpperCase();
  document.getElementById('leakOut').textContent = `SHA1: ${hex}\nPrefix: ${hex.slice(0,5)}\nSuffix: ${hex.slice(5)}`;
});
document.getElementById('toggleLeakPass').addEventListener('click', ()=> {
  const el = document.getElementById('leakPass'); el.type = el.type==='password' ? 'text' : 'password';
  document.getElementById('toggleLeakPass').textContent = el.type==='text' ? 'Hide' : 'Show';
});

/* ---------------------------
   Init small things
   --------------------------- */
pwOut.style.filter = 'none'; // show by default
// ensure some default text
document.getElementById('pwInfo').textContent = 'Press Generate to produce a password.';

// End of script
</script>
</body>
</html>