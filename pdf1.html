<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PDF Toolkit — Thumbnails + Tools</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Bootstrap Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">

  <!-- pdf-lib -->
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>

  <!-- pdf.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

  <!-- FileSaver -->
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <!-- SortableJS -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

  <!-- CryptoJS -->
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>

  <style>
    :root{--accent:#0d6efd}
    body{background:#f4f6fa;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
    .navbar{background:linear-gradient(90deg,var(--accent),#6f42c1);color:#fff}
    .navbar .navbar-brand{color:#fff}
    .tool-card{background:#fff;border-radius:12px;padding:16px;box-shadow:0 8px 24px rgba(12, 34, 63, 0.06)}
    .dropzone{border:2px dashed #e7eefc;border-radius:10px;padding:28px;text-align:center;background:#fff;cursor:pointer}
    .dropzone.dragover{background:#eef6ff}
    .thumb { width:160px; height:220px; border-radius:8px; overflow:hidden; border:1px solid #e6eef9; background:#fff; display:inline-block; margin:8px; position:relative }
    .thumb canvas{ display:block; max-width:100%; max-height:100%; }
    .thumb .badge-pos{ position:absolute; left:8px; top:8px; background:rgba(255,255,255,0.9); padding:3px 6px; border-radius:6px; font-weight:600 }
    .thumb .controls{ position:absolute; right:6px; top:6px; display:flex; gap:6px }
    .thumb .selected { outline:4px solid rgba(13,110,253,0.18) }
    .pdf-viewer { min-height:160px; background:#fff; border-radius:8px; padding:10px; border:1px solid #e9f0fb; overflow:auto }
    .sig-canvas{ border:1px dashed #ccc; border-radius:8px; background:#fff }
    .small-muted{ font-size:.88rem; color:#6c757d }
    footer.small{ margin-top:22px; opacity:.8 }
  </style>
</head>
<body>
  <nav class="navbar py-3 mb-4">
    <div class="container d-flex align-items-center justify-content-between">
      <div class="d-flex align-items-center gap-3">
        <i class="bi bi-file-earmark-pdf-fill fs-2" style="color:#fff"></i>
        <div class="navbar-brand mb-0">PDF Toolkit</div>
      </div>
      <div class="text-white small">Thumbnails + Tools — Client-side</div>
    </div>
  </nav>

  <main class="container mb-5">
    <!-- Upload area -->
    <div class="row mb-4">
      <div class="col-12">
        <div id="dropzone" class="dropzone">
          <div>
            <i class="bi bi-cloud-arrow-up fs-1 text-secondary"></i>
            <div class="mt-2 fw-semibold">Drag & drop a PDF here or click to upload</div>
            <div class="small-muted mt-1">You can also upload images (.jpg/.png) or text (.txt) for conversion.</div>
            <input id="inputFile" type="file" accept=".pdf,image/*,text/plain" style="display:none" />
          </div>
        </div>
      </div>
    </div>

    <div class="row g-3">
      <div class="col-lg-8">
        <div class="tool-card">
          <!-- Tabs -->
          <ul class="nav nav-tabs" id="toolsTabs" role="tablist">
            <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#tab-organize">Organize</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-merge">Merge</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-split">Split</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-watermark">Watermark</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-sign">Sign</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-compress">Compress</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-protect">Protect</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-rotate">Rotate</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-convert">Convert</button></li>
          </ul>

          <div class="tab-content mt-3">
            <!-- ORGANIZE tab -->
            <div class="tab-pane fade show active" id="tab-organize">
              <div class="d-flex align-items-center justify-content-between mb-2">
                <div>
                  <strong>Thumbnails</strong>
                  <div class="small-muted">Drag to reorder, click to select pages. Selected pages are highlighted.</div>
                </div>
                <div class="d-flex gap-2">
                  <button id="btnDeleteSelected" class="btn btn-outline-danger btn-sm"><i class="bi bi-trash"></i> Delete selected</button>
                  <button id="btnRotateSelected" class="btn btn-outline-secondary btn-sm"><i class="bi bi-arrow-clockwise"></i> Rotate selected</button>
                  <button id="btnExportOrganized" class="btn btn-primary btn-sm"><i class="bi bi-download"></i> Export PDF</button>
                </div>
              </div>

              <div id="thumbnails" class="pdf-viewer d-flex flex-wrap"></div>
            </div>

            <!-- MERGE tab -->
            <div class="tab-pane fade" id="tab-merge">
              <div class="row">
                <div class="col-md-8">
                  <h6>Merge PDFs</h6>
                  <div class="small-muted">Add multiple PDF files; reorder them then merge.</div>
                  <div class="mt-2 d-flex gap-2">
                    <input id="mergeInput" type="file" accept="application/pdf" multiple />
                    <button id="btnMergeNow" class="btn btn-success"><i class="bi bi-files"></i> Merge</button>
                  </div>
                  <div id="mergeList" class="mt-3 list-group"></div>
                </div>
                <div class="col-md-4">
                  <h6>Options</h6>
                  <label class="small-muted">Output name</label>
                  <input id="mergeOutName" class="form-control" placeholder="merged.pdf" />
                </div>
              </div>
            </div>

            <!-- SPLIT tab -->
            <div class="tab-pane fade" id="tab-split">
              <h6>Split / Extract Pages</h6>
              <div class="small-muted">Select thumbnails in Organize tab, then extract selected pages or use page ranges below.</div>
              <div class="mt-2 d-flex gap-2">
                <input id="splitFileInput" type="file" accept="application/pdf" />
                <input id="splitRanges" class="form-control" placeholder="e.g. 1,3-5 (pages numbering starts at 1)" />
                <button id="btnSplitRanges" class="btn btn-warning"><i class="bi bi-scissors"></i> Extract ranges</button>
                <button id="btnSplitSelected" class="btn btn-outline-warning">Extract selected</button>
              </div>
            </div>

            <!-- WATERMARK tab -->
            <div class="tab-pane fade" id="tab-watermark">
              <div class="row">
                <div class="col-md-8">
                  <h6>Add watermark</h6>
                  <div class="small-muted">Add text watermark to all pages or selected pages.</div>
                  <input id="watermarkFile" type="file" accept="application/pdf" />
                </div>
                <div class="col-md-4">
                  <label class="form-label small-muted">Watermark text</label>
                  <input id="wmText" class="form-control" placeholder="Confidential" />
                  <label class="form-label small-muted mt-2">Opacity</label>
                  <input id="wmOpacity" type="range" min="0.05" max="0.9" step="0.05" value="0.12" />
                  <label class="form-label small-muted mt-2">Font size</label>
                  <input id="wmSize" type="number" class="form-control" value="48" />
                  <label class="form-label small-muted mt-2">Position</label>
                  <select id="wmPosition" class="form-select">
                    <option value="diagonal">Diagonal</option>
                    <option value="center">Center</option>
                    <option value="top-left">Top-left</option>
                  </select>
                </div>
              </div>
              <div class="mt-3 d-flex gap-2">
                <button id="btnApplyWatermark" class="btn btn-info"><i class="bi bi-droplet"></i> Apply to file</button>
                <button id="btnApplyWatermarkSelected" class="btn btn-outline-info">Apply to selected pages</button>
              </div>
            </div>

            <!-- SIGN tab -->
            <div class="tab-pane fade" id="tab-sign">
              <h6>Signature</h6>
              <div class="small-muted">Draw signature, save it, then place it on selected thumbnail(s).</div>
              <div class="row mt-2">
                <div class="col-md-8">
                  <canvas id="sigCanvas" class="sig-canvas" width="640" height="120"></canvas>
                  <div class="mt-2 d-flex gap-2">
                    <button id="sigClear" class="btn btn-sm btn-outline-secondary">Clear</button>
                    <button id="sigSave" class="btn btn-sm btn-primary">Save signature</button>
                  </div>
                </div>
                <div class="col-md-4">
                  <div id="savedSigs" class="d-flex flex-wrap gap-2"></div>
                  <div class="mt-2">
                    <button id="btnPlaceSignature" class="btn btn-success btn-sm">Place on selected pages</button>
                  </div>
                </div>
              </div>
            </div>

            <!-- COMPRESS tab -->
            <div class="tab-pane fade" id="tab-compress">
              <h6>Compress (lossy)</h6>
              <div class="small-muted">This rasterizes pages and re-embeds them as JPEG at chosen quality.</div>
              <div class="mt-2 d-flex gap-2">
                <input id="compressInput" type="file" accept="application/pdf" />
                <select id="compressQuality" class="form-select w-25">
                  <option value="0.9">High</option>
                  <option value="0.7" selected>Medium</option>
                  <option value="0.45">Low</option>
                </select>
                <button id="btnCompress" class="btn btn-primary">Compress</button>
              </div>
            </div>

            <!-- PROTECT tab -->
            <div class="tab-pane fade" id="tab-protect">
              <h6>Encrypt file (AES)</h6>
              <div class="small-muted">Encrypts the whole file to a .enc file for safe storage/sharing (not PDF-standard open-password).</div>
              <div class="mt-2 d-flex gap-2">
                <input id="protectFile" type="file" />
                <input id="protectPassword" class="form-control w-50" type="password" placeholder="Enter password" />
                <button id="btnEncrypt" class="btn btn-dark">Encrypt</button>
                <button id="btnDecrypt" class="btn btn-outline-secondary">Decrypt</button>
              </div>
            </div>

            <!-- ROTATE tab -->
            <div class="tab-pane fade" id="tab-rotate">
              <h6>Rotate pages</h6>
              <div class="small-muted">Rotate selected pages (applies when exporting).</div>
              <div class="mt-2 d-flex gap-2 align-items-center">
                <select id="rotateAngle" class="form-select w-25">
                  <option value="90">90°</option>
                  <option value="180">180°</option>
                  <option value="270">270°</option>
                </select>
                <button id="btnRotateSelected" class="btn btn-success">Rotate selected</button>
              </div>
            </div>

            <!-- CONVERT tab -->
            <div class="tab-pane fade" id="tab-convert">
              <h6>Convert images / text to PDF</h6>
              <div class="small-muted">Upload images or text files and convert them into a single PDF.</div>
              <div class="mt-2 d-flex gap-2">
                <input id="convertFiles" type="file" accept="image/*,text/plain" multiple />
                <input id="convertOutName" class="form-control w-50" placeholder="converted.pdf" />
                <button id="btnConvertFiles" class="btn btn-primary">Convert</button>
              </div>
            </div>

          </div> <!-- tab-content -->
        </div> <!-- tool-card -->
      </div> <!-- left column -->

      <!-- Right column -->
      <div class="col-lg-4">
        <div class="tool-card mb-3">
          <h6>Preview / Current File</h6>
          <div class="small-muted">Click a thumbnail to preview full-size below.</div>
          <div id="previewArea" class="pdf-viewer mt-2"></div>
          <div class="mt-3 d-flex gap-2">
            <button id="downloadCurrent" class="btn btn-primary btn-sm"><i class="bi bi-download"></i> Download current</button>
            <button id="clearAll" class="btn btn-outline-secondary btn-sm">Clear</button>
          </div>
        </div>

        <div class="tool-card">
          <h6>Status & Logs</h6>
          <div id="status" class="small-muted mb-2">Ready</div>
          <div id="log" style="height:200px; overflow:auto; font-size:.9rem"></div>
        </div>
      </div>
    </div>

    <footer class="small text-center mt-4">Client-side only. For PDF-standard password protection or Office→PDF conversion, a server helper is required.</footer>
  </main>

  <!-- Libraries already loaded in head; now script -->
  <script>
    // --- Setup & state ---
    const { PDFDocument, StandardFonts, rgb, degrees } = PDFLib;
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

    let currentPdfBytes = null;            // Uint8Array / ArrayBuffer of the loaded PDF
    let currentPdfName = null;
    let currentPageCount = 0;
    let currentPagesOrder = [];            // array of original page indices in current order (e.g. [0,1,2,...])
    let pageRotationMap = {};             // mapping originalIndex -> rotationDegrees (cumulative)
    let savedSignatures = [];             // dataURL strings
    let lastExportBytes = null;

    // Elements
    const dropzone = document.getElementById('dropzone');
    const inputFile = document.getElementById('inputFile');
    const thumbnails = document.getElementById('thumbnails');
    const previewArea = document.getElementById('previewArea');
    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status');
    const downloadCurrentBtn = document.getElementById('downloadCurrent');

    // small logger
    function log(msg){
      const d = document.createElement('div'); d.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.prepend(d);
      statusEl.textContent = msg;
    }

    // file -> arrayBuffer
    function fileToArrayBuffer(file){
      return new Promise((res,rej)=>{
        const r = new FileReader();
        r.onload = ()=>res(r.result);
        r.onerror = rej;
        r.readAsArrayBuffer(file);
      });
    }

    function arrayBufferToUint8(arr){ return new Uint8Array(arr); }

    // --- Dropzone interactions ---
    dropzone.addEventListener('click', ()=> inputFile.click());
    dropzone.addEventListener('dragover', e=>{ e.preventDefault(); dropzone.classList.add('dragover'); });
    dropzone.addEventListener('dragleave', ()=> dropzone.classList.remove('dragover'));
    dropzone.addEventListener('drop', async (e)=>{
      e.preventDefault();
      dropzone.classList.remove('dragover');
      if(e.dataTransfer && e.dataTransfer.files.length) await handleIncomingFiles(e.dataTransfer.files);
    });
    inputFile.addEventListener('change', async ()=> { if(inputFile.files.length) await handleIncomingFiles(inputFile.files); });

    async function handleIncomingFiles(fileList){
      // prefer first PDF for thumbnailing; if images/text, convert automatically to PDF
      const files = Array.from(fileList);
      // If there's a pdf file, load the first pdf
      const pdfFile = files.find(f => f.type === 'application/pdf' || f.name.toLowerCase().endsWith('.pdf'));
      if(pdfFile){
        log('Loading PDF: ' + pdfFile.name);
        const arr = await fileToArrayBuffer(pdfFile);
        await loadPdf(arr, pdfFile.name);
        return;
      }
      // else treat as convert - gather images and text into a PDF
      log('Converting non-PDF files to PDF');
      await convertFilesToPdf(files, 'converted.pdf', true);
    }

    // --- PDF load and thumbnail generation (pdf.js for rendering) ---
    async function loadPdf(arrayBuffer, name='document.pdf'){
      try{
        currentPdfBytes = arrayBuffer instanceof ArrayBuffer ? arrayBuffer : (arrayBuffer.buffer || arrayBuffer);
        currentPdfName = name || 'document.pdf';
        const uint8 = new Uint8Array(currentPdfBytes);
        const pdfDoc = await pdfjsLib.getDocument({data:uint8}).promise;
        currentPageCount = pdfDoc.numPages;
        // prepare order array
        currentPagesOrder = Array.from({length:currentPageCount}, (_,i)=>i);
        pageRotationMap = {};
        thumbnails.innerHTML = '';
        previewArea.innerHTML = '';
        // render thumbnails per page
        for(let p=1; p<=pdfDoc.numPages; p++){
          const page = await pdfDoc.getPage(p);
          const viewport = page.getViewport({scale:0.5});
          const canvas = document.createElement('canvas');
          canvas.width = viewport.width; canvas.height = viewport.height;
          const ctx = canvas.getContext('2d');
          await page.render({canvasContext:ctx, viewport}).promise;
          const wrapper = document.createElement('div');
          wrapper.className = 'thumb';
          wrapper.dataset.orig = (p-1); // original index
          wrapper.appendChild(canvas);
          const badge = document.createElement('div'); badge.className = 'badge-pos'; badge.textContent = p;
          wrapper.appendChild(badge);
          const controls = document.createElement('div'); controls.className='controls';
          controls.innerHTML = `<button class="btn btn-sm btn-light btn-select" title="Select"><i class="bi bi-check2"></i></button>
                                <button class="btn btn-sm btn-light btn-rotate" title="Rotate 90°"><i class="bi bi-arrow-clockwise"></i></button>
                                <button class="btn btn-sm btn-danger btn-del" title="Delete"><i class="bi bi-trash"></i></button>`;
          wrapper.appendChild(controls);
          thumbnails.appendChild(wrapper);

          // events
          wrapper.addEventListener('click', (ev)=>{
            if(ev.target.matches('button') || ev.target.closest('button')) return; // skip clicks on buttons
            openPreviewForPage(p);
          });
          wrapper.querySelector('.btn-select').addEventListener('click', (ev)=>{
            ev.stopPropagation();
            wrapper.classList.toggle('selected');
          });
          wrapper.querySelector('.btn-rotate').addEventListener('click', (ev)=>{
            ev.stopPropagation();
            const orig = parseInt(wrapper.dataset.orig,10);
            pageRotationMap[orig] = (pageRotationMap[orig] || 0) + 90;
            wrapper.classList.add('rotated');
            log('Queued rotation 90° for page ' + (orig+1));
          });
          wrapper.querySelector('.btn-del').addEventListener('click', (ev)=>{
            ev.stopPropagation();
            // remove thumbnail and remove orig from order
            const orig = parseInt(wrapper.dataset.orig,10);
            wrapper.remove();
            currentPagesOrder = currentPagesOrder.filter(x => x !== orig);
            log('Removed page ' + (orig+1) + ' from current document view');
          });
        }
        // Enable drag-and-drop reorder with SortableJS
        Sortable.create(thumbnails, {
          animation: 180,
          onEnd: (evt)=>{
            // rebuild currentPagesOrder according to thumbnail DOM order
            const els = Array.from(thumbnails.children);
            currentPagesOrder = els.map(el => parseInt(el.dataset.orig,10));
            log('Reordered pages');
          }
        });

        log(`Loaded ${pdfDoc.numPages} page(s) — ${currentPdfName}`);
        // set preview first page
        openPreviewForPage(1);
        // store lastExportBytes to current
        lastExportBytes = currentPdfBytes;
        downloadCurrentBtn.onclick = ()=> saveAs(new Blob([lastExportBytes], {type:'application/pdf'}), currentPdfName);
      } catch(e){
        console.error(e);
        log('Error loading PDF: ' + e.message);
        alert('Failed to load PDF: ' + e.message);
      }
    }

    // Open a bigger preview for a page (render at higher scale)
    async function openPreviewForPage(pageNumber){
      previewArea.innerHTML = '';
      if(!currentPdfBytes) { previewArea.textContent = 'No PDF loaded'; return; }
      const uint8 = new Uint8Array(currentPdfBytes);
      const doc = await pdfjsLib.getDocument({data:uint8}).promise;
      if(pageNumber < 1 || pageNumber > doc.numPages) return;
      const page = await doc.getPage(pageNumber);
      const viewport = page.getViewport({scale:1.4});
      const canvas = document.createElement('canvas');
      canvas.width = viewport.width; canvas.height = viewport.height;
      const ctx = canvas.getContext('2d');
      await page.render({canvasContext:ctx, viewport}).promise;
      previewArea.appendChild(canvas);
    }

    // --- Convert images/text to PDF ---
    async function convertFilesToPdf(files, outName='converted.pdf', autoOpen=false){
      try{
        const outDoc = await PDFDocument.create();
        for(const f of files){
          if(f.type.startsWith('image/')){
            const arr = await fileToArrayBuffer(f);
            let img;
            if(f.type === 'image/png') img = await outDoc.embedPng(arr); else img = await outDoc.embedJpg(arr);
            const page = outDoc.addPage([img.width, img.height]);
            page.drawImage(img, {x:0,y:0,width:img.width, height:img.height});
            log('Added image ' + f.name);
          } else if(f.type === 'text/plain'){
            const text = await f.text();
            const page = outDoc.addPage();
            const helv = await outDoc.embedFont(StandardFonts.Helvetica);
            page.drawText(text, {x:40,y:700,size:12,font:helv});
            log('Added text file ' + f.name);
          } else if(f.type === 'application/pdf'){
            // merge pdf
            const bytes = await fileToArrayBuffer(f);
            const src = await PDFDocument.load(bytes);
            const copied = await outDoc.copyPages(src, src.getPageIndices());
            copied.forEach(p=> outDoc.addPage(p));
            log('Merged PDF ' + f.name);
          } else {
            log('Skipped unsupported: ' + f.name);
          }
        }
        const bytes = await outDoc.save();
        lastExportBytes = bytes;
        saveAs(new Blob([bytes], {type:'application/pdf'}), outName);
        if(autoOpen) await loadPdf(bytes, outName);
        log('Conversion finished: ' + outName);
      } catch(e){
        console.error(e);
        alert('Convert error: ' + e.message);
      }
    }

    document.getElementById('btnConvertFiles').addEventListener('click', async ()=>{
      const files = Array.from(document.getElementById('convertFiles').files);
      if(!files.length){ alert('Choose files to convert'); return; }
      const name = document.getElementById('convertOutName').value || 'converted.pdf';
      await convertFilesToPdf(files, name, true);
    });

    // --- Merge PDFs ---
    let mergeFilesArr = [];
    const mergeListEl = document.getElementById('mergeList');
    document.getElementById('mergeInput').addEventListener('change', (e)=>{
      const files = Array.from(e.target.files).filter(f=>f.type==='application/pdf');
      for(const f of files){
        mergeFilesArr.push(f);
        const item = document.createElement('div');
        item.className = 'list-group-item d-flex justify-content-between align-items-center';
        item.textContent = f.name;
        const rm = document.createElement('button'); rm.className='btn btn-sm btn-danger'; rm.innerHTML='<i class="bi bi-x-lg"></i>';
        rm.addEventListener('click', ()=>{ mergeFilesArr = mergeFilesArr.filter(x=>x!==f); item.remove(); });
        item.appendChild(rm);
        mergeListEl.appendChild(item);
      }
      Sortable.create(mergeListEl, {animation:150});
    });

    document.getElementById('btnMergeNow').addEventListener('click', async ()=>{
      if(mergeFilesArr.length===0) return alert('Add PDF files to merge');
      const merged = await PDFDocument.create();
      // take DOM order
      const domNames = Array.from(mergeListEl.children).map(x=>x.firstChild.textContent);
      for(const name of domNames){
        const f = mergeFilesArr.find(ff=>ff.name === name);
        if(!f) continue;
        const bytes = await fileToArrayBuffer(f);
        const src = await PDFDocument.load(bytes);
        const copied = await merged.copyPages(src, src.getPageIndices());
        copied.forEach(p=> merged.addPage(p));
        log('Appended ' + f.name);
      }
      const out = await merged.save();
      lastExportBytes = out;
      const outName = document.getElementById('mergeOutName').value || 'merged.pdf';
      saveAs(new Blob([out],{type:'application/pdf'}), outName);
      await loadPdf(out, outName);
      log('Merge complete');
    });

    // --- Split / Extract ---
    document.getElementById('btnSplitRanges').addEventListener('click', async ()=>{
      const splitInput = document.getElementById('splitFileInput').files[0];
      const rangesSpec = document.getElementById('splitRanges').value.trim();
      if(!splitInput) return alert('Choose a PDF to split');
      if(!rangesSpec) return alert('Enter pages or ranges');
      const arr = await fileToArrayBuffer(splitInput);
      const src = await PDFDocument.load(arr);
      const total = src.getPageCount();
      const ranges = parseRanges(rangesSpec, total);
      const out = await PDFDocument.create();
      for(const r of ranges){
        for(let p=r.start-1; p<=r.end-1; p++){
          if(p<0 || p>=total) continue;
          const [copied] = await out.copyPages(src, [p]);
          out.addPage(copied);
        }
      }
      const bytes = await out.save();
      saveAs(new Blob([bytes],{type:'application/pdf'}), 'extracted.pdf');
      await loadPdf(bytes, 'extracted.pdf');
      log('Extracted requested ranges');
    });

    function parseRanges(spec, total){
      const parts = spec.split(',').map(s=>s.trim()).filter(Boolean);
      const out = [];
      for(const p of parts){
        if(p.includes('-')){
          const [a,b] = p.split('-').map(x=>parseInt(x));
          out.push({start: Math.max(1, a), end: Math.min(total, b)});
        } else {
          const n = parseInt(p);
          out.push({start:n, end:n});
        }
      }
      return out;
    }

    // Extract selected thumbnails
    document.getElementById('btnSplitSelected').addEventListener('click', async ()=>{
      if(!currentPagesOrder.length) return alert('No PDF loaded or pages available');
      const selectedEls = Array.from(thumbnails.querySelectorAll('.thumb.selected'));
      if(!selectedEls.length) return alert('Select pages first in Organize');
      const src = await PDFDocument.load(currentPdfBytes);
      const out = await PDFDocument.create();
      for(const el of selectedEls){
        const orig = parseInt(el.dataset.orig,10);
        const [copied] = await out.copyPages(src, [orig]);
        out.addPage(copied);
      }
      const bytes = await out.save();
      saveAs(new Blob([bytes],{type:'application/pdf'}), 'extracted-selected.pdf');
      await loadPdf(bytes, 'extracted-selected.pdf');
      log('Extracted selected pages');
    });

    // --- Watermark ---
    document.getElementById('btnApplyWatermark').addEventListener('click', async ()=>{
      const f = document.getElementById('watermarkFile').files[0];
      if(!f) return alert('Choose a PDF file');
      const arr = await fileToArrayBuffer(f);
      const src = await PDFDocument.load(arr);
      const out = await PDFDocument.create();
      const helv = await out.embedFont(StandardFonts.HelveticaBold);
      const text = document.getElementById('wmText').value || 'Confidential';
      const opacity = parseFloat(document.getElementById('wmOpacity').value);
      const size = parseInt(document.getElementById('wmSize').value) || 48;
      const pos = document.getElementById('wmPosition').value;
      for(let i=0;i<src.getPageCount();i++){
        const [copied] = await out.copyPages(src, [i]);
        const {width, height} = copied.getSize();
        if(pos === 'diagonal'){
          copied.drawText(text, {x: width/4, y: height/2, size, font: helv, rotate: degrees(-30), opacity});
        } else if(pos === 'center'){
          copied.drawText(text, {x: width/2 - (text.length*6), y: height/2, size, font: helv, opacity});
        } else {
          copied.drawText(text, {x: 40, y: height - 60, size, font: helv, opacity});
        }
        out.addPage(copied);
      }
      const bytes = await out.save();
      saveAs(new Blob([bytes],{type:'application/pdf'}), 'watermarked.pdf');
      await loadPdf(bytes, 'watermarked.pdf');
      log('Watermark applied to file');
    });

    // Apply watermark to selected pages only
    document.getElementById('btnApplyWatermarkSelected').addEventListener('click', async ()=>{
      if(!currentPagesOrder.length) return alert('Load a PDF and have thumbnails visible');
      const selectedEls = Array.from(thumbnails.querySelectorAll('.thumb.selected'));
      if(!selectedEls.length) return alert('Select pages to watermark in Organize');
      const src = await PDFDocument.load(currentPdfBytes);
      const out = await PDFDocument.create();
      const helv = await out.embedFont(StandardFonts.HelveticaBold);
      const text = document.getElementById('wmText').value || 'Confidential';
      const opacity = parseFloat(document.getElementById('wmOpacity').value);
      const size = parseInt(document.getElementById('wmSize').value) || 48;
      // copy pages in current order, applying watermark to those selected
      const orderEls = Array.from(thumbnails.children);
      for(const el of orderEls){
        const orig = parseInt(el.dataset.orig,10);
        const [copied] = await out.copyPages(src, [orig]);
        if(el.classList.contains('selected')){
          const {width, height} = copied.getSize();
          copied.drawText(text, {x: width/4, y: height/2, size, font: helv, rotate: degrees(-30), opacity});
        }
        out.addPage(copied);
      }
      const bytes = await out.save();
      saveAs(new Blob([bytes],{type:'application/pdf'}), 'watermarked-selected.pdf');
      await loadPdf(bytes, 'watermarked-selected.pdf');
      log('Watermark applied to selected pages');
    });

    // --- Signature handling ---
    const sigCanvas = document.getElementById('sigCanvas');
    const sctx = sigCanvas.getContext('2d');
    sctx.lineWidth = 2; sctx.strokeStyle = '#111';
    let drawing = false;
    sigCanvas.addEventListener('pointerdown', e=>{ drawing=true; sctx.beginPath(); sctx.moveTo(e.offsetX, e.offsetY); });
    sigCanvas.addEventListener('pointerup', ()=> drawing=false);
    sigCanvas.addEventListener('pointermove', e=>{ if(!drawing) return; sctx.lineTo(e.offsetX,e.offsetY); sctx.stroke(); });

    document.getElementById('sigClear').onclick = ()=> sctx.clearRect(0,0,sigCanvas.width,sigCanvas.height);

    document.getElementById('sigSave').addEventListener('click', ()=>{
      const dataURL = sigCanvas.toDataURL('image/png');
      savedSignatures.push(dataURL);
      const img = document.createElement('img'); img.src = dataURL; img.style.height='48px'; img.style.border='1px solid #ddd'; img.style.borderRadius='6px';
      document.getElementById('savedSigs').appendChild(img);
      log('Signature saved');
    });

    document.getElementById('btnPlaceSignature').addEventListener('click', async ()=>{
      if(!savedSignatures.length) return alert('Save a signature first');
      if(!currentPagesOrder.length) return alert('Load a PDF first and select thumbnails to place into');
      const selectedEls = Array.from(thumbnails.querySelectorAll('.thumb.selected'));
      if(!selectedEls.length) return alert('Select page(s) in Organize to place signature');
      const src = await PDFDocument.load(currentPdfBytes);
      const out = await PDFDocument.create();
      const sigBytes = await (await fetch(savedSignatures[savedSignatures.length-1])).arrayBuffer();
      const sigImg = await out.embedPng(sigBytes);
      // copy pages in current order, placing signature where selected
      const orderEls = Array.from(thumbnails.children);
      for(const el of orderEls){
        const orig = parseInt(el.dataset.orig,10);
        const [copied] = await out.copyPages(src, [orig]);
        if(el.classList.contains('selected')){
          const {width} = copied.getSize();
          const w = Math.min(200, width*0.25);
          const h = (sigImg.height / sigImg.width) * w;
          copied.drawImage(sigImg, {x: width - w - 40, y: 40, width: w, height: h});
        }
        out.addPage(copied);
      }
      const bytes = await out.save();
      saveAs(new Blob([bytes],{type:'application/pdf'}),'signed.pdf');
      await loadPdf(bytes, 'signed.pdf');
      log('Signature placed on selected pages');
    });

    // --- Compress (rasterize pages to JPEG at quality) ---
    document.getElementById('btnCompress').addEventListener('click', async ()=>{
      const f = document.getElementById('compressInput').files[0];
      if(!f) return alert('Choose a PDF to compress');
      const q = parseFloat(document.getElementById('compressQuality').value);
      setTimeout(()=>log('Starting compression...'), 0);
      const arr = await fileToArrayBuffer(f);
      const srcPdf = await pdfjsLib.getDocument({data:new Uint8Array(arr)}).promise;
      const out = await PDFDocument.create();
      for(let p=1;p<=srcPdf.numPages;p++){
        const page = await srcPdf.getPage(p);
        const viewport = page.getViewport({scale:1.5});
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width; canvas.height = viewport.height;
        const ctx = canvas.getContext('2d');
        await page.render({canvasContext:ctx, viewport}).promise;
        const dataUrl = canvas.toDataURL('image/jpeg', q);
        const imgBytes = dataURLToUint8Array(dataUrl);
        const img = await out.embedJpg(imgBytes);
        const pg = out.addPage([img.width, img.height]);
        pg.drawImage(img, {x:0,y:0,width:img.width, height:img.height});
        log('Compressed page ' + p);
      }
      const bytes = await out.save();
      saveAs(new Blob([bytes],{type:'application/pdf'}), 'compressed.pdf');
      await loadPdf(bytes, 'compressed.pdf');
      log('Compression finished');
    });

    // Helper: dataURL -> Uint8Array
    function dataURLToUint8Array(dataURL){
      const base64 = dataURL.split(',')[1];
      const binary = atob(base64);
      const len = binary.length;
      const arr = new Uint8Array(len);
      for(let i=0;i<len;i++) arr[i] = binary.charCodeAt(i);
      return arr;
    }

    // --- Protect: AES encrypt / decrypt whole file as .enc blob ---
    document.getElementById('btnEncrypt').addEventListener('click', async ()=>{
      const f = document.getElementById('protectFile').files[0];
      const pass = document.getElementById('protectPassword').value;
      if(!f) return alert('Choose a file to encrypt');
      if(!pass) return alert('Enter a password');
      const arr = await fileToArrayBuffer(f);
      const wordArray = CryptoJS.lib.WordArray.create(arr);
      const ciphertext = CryptoJS.AES.encrypt(wordArray, pass).toString();
      const blob = new Blob([ciphertext], {type:'application/octet-stream'});
      saveAs(blob, f.name + '.enc');
      log('File encrypted to ' + f.name + '.enc (AES blob)');
    });

    document.getElementById('btnDecrypt').addEventListener('click', async ()=>{
      const f = document.getElementById('protectFile').files[0];
      const pass = document.getElementById('protectPassword').value;
      if(!f) return alert('Choose an .enc file to decrypt');
      if(!pass) return alert('Enter password');
      const txt = await f.text();
      try{
        const bytes = CryptoJS.AES.decrypt(txt, pass);
        const u8 = wordArrayToUint8Array(bytes);
        const blob = new Blob([u8], {type:'application/octet-stream'});
        saveAs(blob, f.name.replace(/\.enc$/,''));
        log('Decrypted ' + f.name);
      } catch(e){
        alert('Decryption failed: wrong password or invalid file');
      }
    });

    function wordArrayToUint8Array(wordArray){
      const len = wordArray.sigBytes;
      const words = wordArray.words;
      const u8 = new Uint8Array(len);
      let idx=0;
      for(let i=0;i<words.length;i++){
        let w = words[i];
        u8[idx++] = (w >> 24) & 0xFF; if(idx>=len) break;
        u8[idx++] = (w >> 16) & 0xFF; if(idx>=len) break;
        u8[idx++] = (w >> 8) & 0xFF; if(idx>=len) break;
        u8[idx++] = (w) & 0xFF; if(idx>=len) break;
      }
      return u8;
    }

    // --- Rotate selected thumbnails (queues rotation) ---
    document.getElementById('btnRotateSelected').addEventListener('click', async ()=>{
      const angle = parseInt(document.getElementById('rotateAngle').value) || 90;
      const sel = Array.from(thumbnails.querySelectorAll('.thumb.selected'));
      if(!sel.length) return alert('Select pages to rotate in Organize');
      sel.forEach(el=>{
        const orig = parseInt(el.dataset.orig,10);
        pageRotationMap[orig] = (pageRotationMap[orig] || 0) + angle;
        log('Queued rotation ' + angle + '° for page ' + (orig+1));
      });
      alert('Rotation queued — export will apply rotations when saving/exporting');
    });

    // Delete selected thumbnails
    document.getElementById('btnDeleteSelected').addEventListener('click', ()=>{
      const sel = Array.from(thumbnails.querySelectorAll('.thumb.selected'));
      if(!sel.length) return alert('Select pages to delete');
      sel.forEach(el=>{
        const orig = parseInt(el.dataset.orig,10);
        el.remove();
        currentPagesOrder = currentPagesOrder.filter(x => x !== orig);
        log('Deleted page ' + (orig+1));
      });
    });

    // Export organized PDF (applies ordering, deletions, rotations)
    document.getElementById('btnExportOrganized').addEventListener('click', async ()=>{
      if(!currentPagesOrder.length) return alert('No pages to export');
      const src = await PDFDocument.load(currentPdfBytes);
      const out = await PDFDocument.create();
      // For each thumbnail in current DOM order, copy corresponding original page and apply rotation (if any)
      const orderEls = Array.from(thumbnails.children);
      for(let i=0;i<orderEls.length;i++){
        const orig = parseInt(orderEls[i].dataset.orig,10);
        const [copied] = await out.copyPages(src, [orig]);
        // apply rotation if present for this original index
        const rot = pageRotationMap[orig] || 0;
        if(rot % 360 !== 0) copied.setRotation(degrees(rot));
        out.addPage(copied);
      }
      const bytes = await out.save();
      lastExportBytes = bytes;
      saveAs(new Blob([bytes],{type:'application/pdf'}), 'organized.pdf');
      await loadPdf(bytes, 'organized.pdf');
      log('Exported organized PDF');
    });

    // Rotate selected (apply immediately by exporting and reloading)
    document.getElementById('btnRotateSelected').addEventListener('click', async ()=>{
      // Use the same logic as export but apply more rotation
      document.getElementById('btnExportOrganized').click();
    });

    // --- Rotate individual queued rotations handled on export (done above) ---

    // --- Convert by drag-and-drop handled earlier via handleIncomingFiles ---

    // --- Utilities: clear, preview click behavior ---
    document.getElementById('clearAll').addEventListener('click', ()=>{
      thumbnails.innerHTML = '';
      previewArea.innerHTML = '';
      currentPdfBytes = null;
      currentPagesOrder = [];
      pageRotationMap = {};
      lastExportBytes = null;
      log('Cleared current document');
    });

    // --- Download current (lastExportBytes) ---
    downloadCurrentBtn.addEventListener('click', ()=> {
      if(!lastExportBytes) return alert('No PDF ready to download');
      saveAs(new Blob([lastExportBytes], {type:'application/pdf'}), currentPdfName || 'document.pdf');
    });

    // --- Helper: when loadPdf sets thumbnail order (orig indices may not be contiguous after deletes),
    // we keep currentPagesOrder updated when thumbnails reorder or delete (handled by events above) ---

    // Initialize empty Sortable for thumbnails container (will work when children exist)
    Sortable.create(thumbnails, {animation:180});

    // initial log
    log('PDF Toolkit ready — upload a PDF to begin');

    // small helper: attach split input quick load if user chooses a file
    document.getElementById('splitFileInput').addEventListener('change', async (e)=>{
      if(!e.target.files.length) return;
      const arr = await fileToArrayBuffer(e.target.files[0]);
      await loadPdf(arr, e.target.files[0].name);
    });

    // Utility: if users add merge files then reorder via DOM names, we need to keep mergeFilesArr consistent.
    // Done via matching name when executing merge.

  </script>
</body>
</html>