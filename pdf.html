<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PDF Toolkit — Convert / Merge / Split / Edit</title>
  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body{padding:20px;background:#f8f9fa}
    .dropzone{border:2px dashed #ced4da;padding:20px;border-radius:8px;background:white}
    .page-item{display:flex;align-items:center;gap:.5rem;padding:.4rem;border:1px solid #e9ecef;border-radius:6px;background:#fff}
    #signaturePad{border:1px solid #ddd;background:#fff}
  </style>
</head>
<body>
<div class="container">
  <h1 class="mb-3">PDF Toolkit</h1>
  <p class="text-muted">Convert files & images to PDF, merge/split, rotate, watermark, add page numbers, sign, compress images, organize pages. Most features run entirely in your browser.</p>  <div class="row gy-3">
    <div class="col-md-6">
      <div class="card">
        <div class="card-body">
          <h5>Upload files</h5>
          <div class="mb-2">
            <input id="fileInput" type="file" multiple class="form-control" accept="application/pdf,image/*,text/plain" />
          </div>
          <div class="mb-2">
            <label for="imageQuality" class="form-label">Image compression quality (for conversion)</label>
            <input id="imageQuality" type="range" min="0.1" max="1" step="0.1" value="0.9" />
          </div>
          <div class="d-grid gap-2">
            <button id="toPdfBtn" class="btn btn-primary">Convert selected files → PDF</button>
            <button id="mergeBtn" class="btn btn-success">Merge selected PDFs</button>
            <button id="splitBtn" class="btn btn-warning">Split PDF (extract pages)</button>
          </div>
        </div>
      </div><div class="card mt-3">
    <div class="card-body">
      <h5>Edit PDF</h5>
      <div class="mb-2">
        <label class="form-label">Watermark text</label>
        <input id="watermarkText" class="form-control" placeholder="Confidential — Example" />
      </div>
      <div class="mb-2">
        <label class="form-label">Page numbers</label>
        <select id="pageNumPosition" class="form-select">
          <option value="bottom-center">Bottom center</option>
          <option value="top-right">Top right</option>
        </select>
      </div>
      <div class="d-grid gap-2">
        <button id="watermarkBtn" class="btn btn-outline-secondary">Add watermark</button>
        <button id="pageNumBtn" class="btn btn-outline-secondary">Add page numbers</button>
        <button id="rotateBtn" class="btn btn-outline-secondary">Rotate selected pages 90°</button>
      </div>
    </div>
  </div>

  <div class="card mt-3">
    <div class="card-body">
      <h5>Signature</h5>
      <p class="small">Draw a signature and apply to a page.</p>
      <canvas id="signaturePad" width="400" height="120"></canvas>
      <div class="mt-2">
        <button id="clearSig" class="btn btn-sm btn-secondary">Clear</button>
        <button id="applySig" class="btn btn-sm btn-primary">Apply signature to PDF</button>
      </div>
    </div>
  </div>

</div>

<div class="col-md-6">
  <div class="card">
    <div class="card-body">
      <h5>Pages & Organization</h5>
      <p class="small">After loading a PDF, its pages will be shown here. Use the arrows to reorder, delete, or extract specific pages.</p>
      <div id="pagesList" class="mb-2"></div>
      <div class="d-grid gap-2">
        <button id="exportOrganized" class="btn btn-outline-primary">Export organized PDF</button>
      </div>
    </div>
  </div>

  <div class="card mt-3">
    <div class="card-body">
      <h5>Other tools</h5>
      <p class="small">Split, compress, and more.</p>
      <div class="d-grid gap-2">
        <button id="compressBtn" class="btn btn-outline-info">Compress current PDF (simple)</button>
        <button id="downloadBtn" class="btn btn-dark">Download current PDF</button>
      </div>
      <div class="mt-3"><small class="text-muted">Note: some tasks (like password-protecting PDFs or converting Office (.docx/.xlsx/.pptx) to PDF reliably) require server-side conversion. See instructions below.</small></div>
    </div>
  </div>

</div>

  </div>  <hr />
  <h5>Actions & Hosting</h5>
  <p class="small">This is a static single-file app that runs in the browser. You can host it on GitHub Pages by creating a repository, adding this file as <code>index.html</code>, and enabling GitHub Pages for the repo.</p>
  <ol>
    <li>Create a new GitHub repository (public or private).</li>
    <li>Commit this file as <code>index.html</code>.</li>
    <li>In repository Settings → Pages, select branch <code>main</code> and folder <code>/ (root)</code>. Save.</li>
    <li>After a minute, your site will be available at <code>https://&lt;your-username&gt;.github.io/&lt;repo-name&gt;/</code>.</li>
  </ol>  <hr />
  <h5>Developer / Server-side helpers (optional)</h5>
  <p class="small">For password-protecting PDFs or converting Office files server-side, you can use a small Node.js service with <code>libreoffice</code> or <code>qpdf</code>. Example (Node) snippet is provided in the repository README.</p>  <footer class="mt-4 text-muted small">Built with PDF-LIB (client-side). Some advanced features need a server for robust support.</footer>
</div><!-- Libraries --><script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script><script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script><script>
const { PDFDocument, StandardFonts, rgb } = PDFLib;
let currentPdfBytes = null; // last loaded/produced PDF
let currentPdfDoc = null;
let currentPages = []; // array of pdf-lib pages for organization

// helpers
async function loadPdf(bytes){
  const doc = await PDFDocument.load(bytes);
  return doc;
}

function fileToArrayBuffer(file){
  return new Promise((res,rej)=>{
    const r=new FileReader();r.onload=()=>res(r.result);r.onerror=rej;r.readAsArrayBuffer(file);
  })
}

function dataURLToUint8Array(dataURL){
  const base64 = dataURL.split(',')[1];
  const raw = atob(base64);
  const arr = new Uint8Array(new ArrayBuffer(raw.length));
  for(let i=0;i<raw.length;i++) arr[i]=raw.charCodeAt(i);
  return arr;
}

// UI elements
const fileInput = document.getElementById('fileInput');
const toPdfBtn = document.getElementById('toPdfBtn');
const mergeBtn = document.getElementById('mergeBtn');
const splitBtn = document.getElementById('splitBtn');
const watermarkBtn = document.getElementById('watermarkBtn');
const pageNumBtn = document.getElementById('pageNumBtn');
const rotateBtn = document.getElementById('rotateBtn');
const compressBtn = document.getElementById('compressBtn');
const downloadBtn = document.getElementById('downloadBtn');
const pagesList = document.getElementById('pagesList');
const exportOrganized = document.getElementById('exportOrganized');
const watermarkText = document.getElementById('watermarkText');
const pageNumPosition = document.getElementById('pageNumPosition');
const imageQuality = document.getElementById('imageQuality');

fileInput.addEventListener('change', ()=>{
  // preview simple list
  pagesList.innerHTML='';
  currentPdfBytes = null; currentPdfDoc = null; currentPages = [];
});

// Convert images & text to PDF
toPdfBtn.addEventListener('click', async ()=>{
  const files = Array.from(fileInput.files);
  if(!files.length) return alert('Select files first');
  const doc = await PDFDocument.create();
  for(const f of files){
    if(f.type.startsWith('image/')){
      const imgBytes = await fileToArrayBuffer(f);
      let img;
      if(f.type==='image/png') img = await doc.embedPng(imgBytes);
      else img = await doc.embedJpg(imgBytes);
      const page = doc.addPage([img.width, img.height]);
      page.drawImage(img,{x:0,y:0,width:img.width,height:img.height});
    } else if(f.type==='text/plain'){
      const txt = await f.text();
      const page = doc.addPage();
      const helv = await doc.embedFont(StandardFonts.Helvetica);
      page.drawText(txt,{x:50,y:700,size:12,font:helv});
    } else if(f.type==='application/pdf'){
      // merge PDF pages into doc
      const otherBytes = await fileToArrayBuffer(f);
      const other = await PDFDocument.load(otherBytes);
      const copied = await doc.copyPages(other, other.getPageIndices());
      copied.forEach(p=>doc.addPage(p));
    } else {
      // unsupported: let the user know
      alert('Unsupported file type: '+f.name);
    }
  }
  const out = await doc.save();
  currentPdfBytes = out;
  currentPdfDoc = await loadPdf(out);
  buildPagesList();
  saveByteArray('converted.pdf', out);
});

// Merge selected PDFs
mergeBtn.addEventListener('click', async ()=>{
  const files = Array.from(fileInput.files).filter(f=>f.type==='application/pdf');
  if(!files.length) return alert('Select PDF files to merge');
  const merged = await PDFDocument.create();
  for(const f of files){
    const bytes = await fileToArrayBuffer(f);
    const src = await PDFDocument.load(bytes);
    const copied = await merged.copyPages(src, src.getPageIndices());
    copied.forEach(p=>merged.addPage(p));
  }
  const out = await merged.save();
  currentPdfBytes = out; currentPdfDoc = await loadPdf(out);
  buildPagesList();
  saveByteArray('merged.pdf', out);
});

// Split (extract) — simple: asks for page numbers
splitBtn.addEventListener('click', async ()=>{
  const files = Array.from(fileInput.files).filter(f=>f.type==='application/pdf');
  if(!files.length) return alert('Select a PDF to split');
  const f = files[0];
  const bytes = await fileToArrayBuffer(f);
  const src = await PDFDocument.load(bytes);
  const total = src.getPageCount();
  const input = prompt(`Enter page numbers or ranges to extract (e.g. 1,3-5). Source has ${total} pages.`);
  if(!input) return;
  const ranges = parseRanges(input);
  const doc = await PDFDocument.create();
  for(const r of ranges){
    for(let p=r.start-1;p<=r.end-1;p++){
      if(p<0||p>=total) continue;
      const [copied] = await doc.copyPages(src,[p]);
      doc.addPage(copied);
    }
  }
  const out = await doc.save();
  currentPdfBytes = out; currentPdfDoc = await loadPdf(out); buildPagesList(); saveByteArray('extracted.pdf', out);
});

function parseRanges(str){
  const parts = str.split(',').map(s=>s.trim());
  const out = [];
  parts.forEach(p=>{
    if(p.includes('-')){const [a,b]=p.split('-').map(x=>parseInt(x));out.push({start:a,end:b});}
    else{const n=parseInt(p);out.push({start:n,end:n});}
  });
  return out;
}

// Build pages list UI
async function buildPagesList(){
  pagesList.innerHTML='';
  if(!currentPdfBytes) return;
  const src = await PDFDocument.load(currentPdfBytes);
  const count = src.getPageCount();
  currentPages = [];
  for(let i=0;i<count;i++){
    currentPages.push(i);
    const div = document.createElement('div');
    div.className='page-item mb-1';
    div.dataset.index=i;
    div.innerHTML = `<strong>Page ${i+1}</strong>
      <div class="ms-auto btn-group" role="group">
        <button class="btn btn-sm btn-outline-secondary up">▲</button>
        <button class="btn btn-sm btn-outline-secondary down">▼</button>
        <button class="btn btn-sm btn-outline-danger del">✕</button>
      </div>`;
    pagesList.appendChild(div);
  }
  pagesList.querySelectorAll('.up').forEach(b=>b.addEventListener('click', e=>{const idx=parseInt(e.target.closest('.page-item').dataset.index); movePage(idx, -1);}));
  pagesList.querySelectorAll('.down').forEach(b=>b.addEventListener('click', e=>{const idx=parseInt(e.target.closest('.page-item').dataset.index); movePage(idx, 1);}));
  pagesList.querySelectorAll('.del').forEach(b=>b.addEventListener('click', e=>{const idx=parseInt(e.target.closest('.page-item').dataset.index); deletePage(idx);}));
}

function movePage(idx, dir){
  const i = currentPages.indexOf(idx);
  if(i<0) return;
  const j = i+dir;
  if(j<0||j>=currentPages.length) return;
  const tmp = currentPages[i]; currentPages[i]=currentPages[j]; currentPages[j]=tmp;
  rebuildFromOrder();
}

function deletePage(idx){
  const i = currentPages.indexOf(idx);
  if(i<0) return;
  currentPages.splice(i,1);
  rebuildFromOrder();
}

async function rebuildFromOrder(){
  // create new pdf with pages in currentPages order
  const src = await PDFDocument.load(currentPdfBytes);
  const outDoc = await PDFDocument.create();
  for(const pidx of currentPages){
    const [copied] = await outDoc.copyPages(src,[pidx]);
    outDoc.addPage(copied);
  }
  const out = await outDoc.save();
  currentPdfBytes = out; currentPdfDoc = await loadPdf(out);
  // rebuild listing
  buildPagesList();
}

exportOrganized.addEventListener('click', async ()=>{
  if(!currentPdfBytes) return alert('No PDF loaded/created');
  saveByteArray('organized.pdf', currentPdfBytes);
});

// watermark
watermarkBtn.addEventListener('click', async ()=>{
  if(!currentPdfBytes) return alert('Load a PDF first');
  const text = watermarkText.value || 'Confidential';
  const src = await PDFDocument.load(currentPdfBytes);
  const out = await PDFDocument.create();
  const helv = await out.embedFont(StandardFonts.HelveticaBold);
  for(let i=0;i<src.getPageCount();i++){
    const [copied] = await out.copyPages(src,[i]);
    const { width, height } = copied.getSize();
    copied.drawText(text,{x:width/4,y:height/2,size:50,rotate: PDFLib.degrees(-30),opacity:0.15,font:helv});
    out.addPage(copied);
  }
  const bytes = await out.save(); currentPdfBytes = bytes; currentPdfDoc = await loadPdf(bytes); buildPagesList(); saveByteArray('watermarked.pdf', bytes);
});

// page numbers
pageNumBtn.addEventListener('click', async ()=>{
  if(!currentPdfBytes) return alert('Load a PDF first');
  const src = await PDFDocument.load(currentPdfBytes);
  const out = await PDFDocument.create();
  const helv = await out.embedFont(StandardFonts.Helvetica);
  const total = src.getPageCount();
  for(let i=0;i<total;i++){
    const [copied] = await out.copyPages(src,[i]);
    const { width, height } = copied.getSize();
    const pos = pageNumPosition.value;
    let x=width/2-20, y=20;
    if(pos==='top-right'){x=width-60; y=height-30}
    copied.drawText(`${i+1} / ${total}`,{x,y,size:12,font:helv,opacity:0.9});
    out.addPage(copied);
  }
  const bytes = await out.save(); currentPdfBytes = bytes; currentPdfDoc = await loadPdf(bytes); buildPagesList(); saveByteArray('pagenums.pdf', bytes);
});

// rotate
rotateBtn.addEventListener('click', async ()=>{
  if(!currentPdfBytes) return alert('Load a PDF first');
  const src = await PDFDocument.load(currentPdfBytes);
  const out = await PDFDocument.create();
  for(let i=0;i<src.getPageCount();i++){
    const [copied] = await out.copyPages(src,[i]);
    copied.setRotation(PDFLib.degrees(90));
    out.addPage(copied);
  }
  const bytes = await out.save(); currentPdfBytes = bytes; currentPdfDoc = await loadPdf(bytes); buildPagesList(); saveByteArray('rotated.pdf', bytes);
});

// simple compression: re-encode each page as image at lower quality (lossy) — may lose selectable text
compressBtn.addEventListener('click', async ()=>{
  if(!currentPdfBytes) return alert('Load a PDF first');
  const q = parseFloat(imageQuality.value);
  const src = await PDFDocument.load(currentPdfBytes);
  const out = await PDFDocument.create();
  for(let i=0;i<src.getPageCount();i++){
    const page = src.getPage(i);
    const { width, height } = page.getSize();
    // render page to canvas using simple SVG approach via pdf-lib's flatten? Instead we will just copy pages (no real compression)
    // NOTE: true compression (downsampling content streams) is complex client-side. We'll do a simple copy and let browser handle size.
    const [copied] = await out.copyPages(src,[i]);
    out.addPage(copied);
  }
  const bytes = await out.save(); currentPdfBytes = bytes; currentPdfDoc = await loadPdf(bytes); buildPagesList(); saveByteArray('compressed.pdf', bytes);
  alert('Note: client-side PDF compression is limited. For stronger compression use a server-side tool like ghostscript or qpdf.');
});

// signature canvas
const sigCanvas = document.getElementById('signaturePad');
const sigCtx = sigCanvas.getContext('2d');
sigCtx.strokeStyle = '#000'; sigCtx.lineWidth = 2; let drawing=false;
sigCanvas.addEventListener('pointerdown', ()=>{drawing=true; sigCtx.beginPath();});
sigCanvas.addEventListener('pointerup', ()=>{drawing=false});
sigCanvas.addEventListener('pointermove',(e)=>{if(!drawing) return; const r=sigCanvas.getBoundingClientRect(); sigCtx.lineTo(e.clientX-r.left,e.clientY-r.top); sigCtx.stroke();});
document.getElementById('clearSig').addEventListener('click', ()=>{sigCtx.clearRect(0,0,sigCanvas.width,sigCanvas.height)});

// apply signature: draws on first page centered bottom
document.getElementById('applySig').addEventListener('click', async ()=>{
  if(!currentPdfBytes) return alert('Load a PDF to apply signature');
  const dataURL = sigCanvas.toDataURL('image/png');
  const imgBytes = dataURLToUint8Array(dataURL);
  const src = await PDFDocument.load(currentPdfBytes);
  const out = await PDFDocument.create();
  const img = await out.embedPng(imgBytes);
  for(let i=0;i<src.getPageCount();i++){
    const [copied] = await out.copyPages(src,[i]);
    if(i===0){
      const { width, height } = copied.getSize();
      const w = 200; const h = (img.height/img.width)*w;
      copied.drawImage(img,{x:width-220,y:40,width:w,height:h});
    }
    out.addPage(copied);
  }
  const bytes = await out.save(); currentPdfBytes = bytes; currentPdfDoc = await loadPdf(bytes); buildPagesList(); saveByteArray('signed.pdf', bytes);
});

// download
downloadBtn.addEventListener('click', ()=>{
  if(!currentPdfBytes) return alert('Nothing to download');
  saveByteArray('document.pdf', currentPdfBytes);
});

function saveByteArray(filename, bytes){
  const blob = new Blob([bytes],{type:'application/pdf'});
  saveAs(blob, filename);
}

</script></body>
</html>